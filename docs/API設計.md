# LINE Bot ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å¯¾å¿œ è‡ªç„¶è¨€èªã‚·ã‚¹ãƒ†ãƒ 

### åŸºæœ¬çš„ãªä½¿ç”¨æ–¹æ³•

### @ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å½¢å¼ã§ã®æ“ä½œ

#### ä¸€èˆ¬ã‚¹ã‚¿ãƒƒãƒ•ç”¨ï¼ˆè‡ªç„¶è¨€èªå¯¾å¿œï¼‰

**ã‚·ãƒ•ãƒˆé–¢é€£**
```
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä»Šæœˆã®ã‚·ãƒ•ãƒˆ
â†’ å½“æœˆã®ã‚·ãƒ•ãƒˆè¡¨ã‚’è¡¨ç¤º

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ˜æ—¥ã®ã‚·ãƒ•ãƒˆæ•™ãˆã¦
â†’ æ˜æ—¥ã®ã‚·ãƒ•ãƒˆè©³ç´°ã‚’è¡¨ç¤º

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆå¸Œæœ›ã§ã™ã€‚å¹³æ—¥9æ™‚ã‹ã‚‰17æ™‚ã€åœŸæ—¥ä¼‘ã¿
â†’ ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã€ä»®ã‚·ãƒ•ãƒˆã«è‡ªå‹•åæ˜ 

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥é€±ã®ç«æ›œæ—¥ä»£ã‚ã£ã¦ã‚‚ã‚‰ãˆã¾ã™ã‹
â†’ ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã€ç®¡ç†è€…ã«é€šçŸ¥

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚·ãƒ•ãƒˆè¡¨ã®PDFæ¬²ã—ã„
â†’ PDFãƒ»ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ã‚’é€ä¿¡
```

**æƒ…å ±ç¢ºèª**
```
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ãŠçŸ¥ã‚‰ã›æ•™ãˆã¦
â†’ ç¾åœ¨ã®å…±æœ‰äº‹é …ã‚’è¡¨ç¤º

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ç§ã®ã‚·ãƒ•ãƒˆæå‡ºçŠ¶æ³ã¯ï¼Ÿ
â†’ è‡ªåˆ†ã®æå‡ºçŠ¶æ³ã‚’ç¢ºèª

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä½¿ã„æ–¹æ•™ãˆã¦
â†’ åˆ©ç”¨å¯èƒ½ãªæ©Ÿèƒ½ã‚’èª¬æ˜
```

#### ç®¡ç†è€…ç”¨ï¼ˆè²¬ä»»è€…ã®ã¿ï¼‰

**ã‚·ãƒ•ãƒˆç®¡ç†**
```
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ä»®ã‚·ãƒ•ãƒˆè¦‹ã›ã¦
â†’ ä»®ã‚·ãƒ•ãƒˆè¡¨ç¤ºï¼ˆåã‚Šæ¤œçŸ¥çµæœä»˜ãï¼‰

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ äººæ‰‹ä¸è¶³ã®è©³ç´°æ•™ãˆã¦
â†’ ä¸è¶³ç®‡æ‰€ã®è©³ç´°åˆ†æã‚’è¡¨ç¤º

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ 1æœˆ20æ—¥ã€ç”°ä¸­ã•ã‚“ã‚’æ´—ã„å ´ã®9æ™‚ã‹ã‚‰17æ™‚ã«é…ç½®
â†’ æ‰‹å‹•ã§ã‚·ãƒ•ãƒˆèª¿æ•´

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆç¢ºå®šã—ã¦
â†’ ä»®ã‚·ãƒ•ãƒˆã‚’ç¢ºå®šã—ã€å…¨å“¡ã«é€šçŸ¥
```

**ç‰¹åˆ¥æœŸé–“è¨­å®š**
```
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ãŠç›†ä¼‘ã¿æœŸé–“ã‚’8æœˆ11æ—¥ã‹ã‚‰15æ—¥ã¾ã§ã€ãƒ›ãƒ¼ãƒ«2äººè¿½åŠ ã§è¨­å®š
â†’ ç‰¹åˆ¥æœŸé–“ã‚’è¨­å®š

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¦ã‚£ãƒ¼ã‚¯ã‚’4æœˆ29æ—¥ã‹ã‚‰5æœˆ5æ—¥ã§è¨­å®š
â†’ é€£ä¼‘æœŸé–“ã‚’è¨­å®š

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ è¨­å®šæ¸ˆã¿ã®ç‰¹åˆ¥æœŸé–“æ•™ãˆã¦
â†’ ç¾åœ¨ã®ç‰¹åˆ¥æœŸé–“ä¸€è¦§ã‚’è¡¨ç¤º
```

## è‡ªç„¶è¨€èªå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ”¹è‰¯ç‰ˆï¼‰

### ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³è§£æã‚¨ãƒ³ã‚¸ãƒ³
```javascript
// lib/nlp/mention-parser.js
export class MentionParser {
  constructor() {
    this.botMentions = [
      '@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ',
      '@ã‚·ãƒ•ãƒˆ',
      '@shift',
      '@bot'
    ];
    
    this.intentPatterns = {
      // ã‚·ãƒ•ãƒˆç¢ºèªç³»
      shiftQuery: [
        /(ä»Šæœˆ|å½“æœˆ|ä»Šæ—¥|æ˜æ—¥|æ¥é€±|æ¥æœˆ)ã®?ã‚·ãƒ•ãƒˆ/,
        /ã‚·ãƒ•ãƒˆ.*?(ç¢ºèª|æ•™ãˆã¦|è¦‹ã›ã¦|è¡¨ç¤º)/,
        /(æ˜æ—¥|ä»Šæ—¥).*?(å‹¤å‹™|ã‚·ãƒ•ãƒˆ)/,
        /(\d+)æœˆ(\d+)æ—¥.*?ã‚·ãƒ•ãƒˆ/
      ],
      
      // ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡º
      shiftRequest: [
        /(æ¥æœˆ|å†æ¥æœˆ|\d+æœˆ).*?å¸Œæœ›/,
        /ã‚·ãƒ•ãƒˆ.*?å¸Œæœ›/,
        /(å¹³æ—¥|åœŸæ—¥|é€±æœ«).*?(æ™‚é–“|å‹¤å‹™)/,
        /(\d{1,2})æ™‚.*?(\d{1,2})æ™‚/
      ],
      
      // ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›  
      changeRequest: [
        /(ä»£ã‚ã£ã¦|äº¤ä»£|å¤‰æ›´).*?(ã‚‚ã‚‰ãˆ|ã—ã¦|ãŠé¡˜ã„)/,
        /(ä¼‘ã¿|ãŠä¼‘ã¿).*?(ã‚‚ã‚‰ãˆ|ã—ãŸã„|ãŠé¡˜ã„)/,
        /(æ€¥ç”¨|ç”¨äº‹|ä½“èª¿).*?(ä»£ã‚ã‚Š|äº¤ä»£)/,
        /(æ˜æ—¥|æ¥é€±|ä»Šåº¦).*?(ä»£ã‚ã£ã¦|äº¤ä»£)/
      ],
      
      // PDFãƒ»ç”»åƒè¦æ±‚
      pdfRequest: [
        /(PDF|pdf).*?(æ¬²ã—ã„|ä¸‹ã•ã„|ãã ã•ã„|é ‚æˆ´)/,
        /(ç”»åƒ|å†™çœŸ).*?(æ¬²ã—ã„|ä¸‹ã•ã„|ä¿å­˜)/,
        /ã‚·ãƒ•ãƒˆè¡¨.*?(ä¿å­˜|ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰)/,
        /(å°åˆ·|ãƒ—ãƒªãƒ³ãƒˆ).*?(ã—ãŸã„|ã™ã‚‹)/
      ],
      
      // å…±æœ‰äº‹é …ç¢ºèª
      noticeQuery: [
        /(ãŠçŸ¥ã‚‰ã›|é€£çµ¡|å…±æœ‰).*?(æ•™ãˆã¦|ç¢ºèª|è¦‹ã›ã¦)/,
        /(æ³¨æ„|å¤§äº‹|é‡è¦).*?(ã“ã¨|äº‹é …)/,
        /ä½•ã‹.*?(é€£çµ¡|ãŠçŸ¥ã‚‰ã›)/
      ],
      
      // ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹ç¢ºèª
      statusQuery: [
        /(æå‡º|çŠ¶æ³).*?(ç¢ºèª|æ•™ãˆã¦)/,
        /(ç§|è‡ªåˆ†).*?(ã‚·ãƒ•ãƒˆ|çŠ¶æ³)/,
        /å¸Œæœ›.*?(å‡ºã—ãŸ|æå‡º)/
      ],
      
      // ãƒ˜ãƒ«ãƒ—
      helpRequest: [
        /(ä½¿ã„æ–¹|æ“ä½œ|æ–¹æ³•).*?(æ•™ãˆã¦|åˆ†ã‹ã‚‰ãªã„)/,
        /(ä½•|ã©ã†).*?(ã§ãã‚‹|ã™ã‚‹)/,
        /(ãƒ˜ãƒ«ãƒ—|help)/,
        /(æ©Ÿèƒ½|ã‚³ãƒãƒ³ãƒ‰).*?(ä¸€è¦§|æ•™ãˆã¦)/
      ],
      
      // ç®¡ç†è€…æ©Ÿèƒ½
      adminPreview: [
        /(ä»®|ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼).*?ã‚·ãƒ•ãƒˆ.*?(è¦‹ã›ã¦|ç¢ºèª|è¡¨ç¤º)/,
        /(æ¥æœˆ|ä»Šæœˆ).*?(çŠ¶æ³|æ§˜å­).*?(ç¢ºèª|æ•™ãˆã¦)/
      ],
      
      adminConflicts: [
        /(äººæ‰‹ä¸è¶³|ä¸è¶³|è¶³ã‚Šãªã„).*?(è©³ç´°|æ•™ãˆã¦|ç¢ºèª)/,
        /(å•é¡Œ|èª²é¡Œ|èª¿æ•´).*?(ç®‡æ‰€|å ´æ‰€)/,
        /(åã‚Š|ãƒãƒ©ãƒ³ã‚¹).*?(ç¢ºèª|ãƒã‚§ãƒƒã‚¯)/
      ],
      
      adminAssign: [
        /(\d+)æœˆ(\d+)æ—¥.*?(é…ç½®|å‰²ã‚Šå½“ã¦|ã‚·ãƒ•ãƒˆ)/,
        /(.*?)ã‚’(.*?)ã«(\d{1,2})æ™‚ã‹ã‚‰(\d{1,2})æ™‚/,
        /(.*?)ã•ã‚“ã‚’(.*?)ã®(\d{1,2})[:-](\d{2})/
      ],
      
      adminConfirm: [
        /(ã‚·ãƒ•ãƒˆ|æ¥æœˆ).*?(ç¢ºå®š|æ±ºå®š).*?(ã—ã¦|ãŠé¡˜ã„)/,
        /(ç¢ºå®š|æ±ºå®š).*?ã‚·ãƒ•ãƒˆ/
      ],
      
      eventManagement: [
        /(ãŠç›†|å¹´æœ«|æ­£æœˆ|GW|ã‚´ãƒ¼ãƒ«ãƒ‡ãƒ³ã‚¦ã‚£ãƒ¼ã‚¯).*?(è¨­å®š|æœŸé–“)/,
        /(ç‰¹åˆ¥|ã‚¤ãƒ™ãƒ³ãƒˆ).*?(æœŸé–“|è¨­å®š)/,
        /(\d+)æœˆ(\d+)æ—¥ã‹ã‚‰(\d+)æœˆ?(\d+)æ—¥.*?(è¨­å®š|æœŸé–“)/
      ]
    };
  }
  
  parse(text, user) {
    // @ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã®ç¢ºèª
    const mention = this.extractMention(text);
    if (!mention) {
      return null; // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãªã—ã¯å‡¦ç†ã—ãªã„
    }
    
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³éƒ¨åˆ†ã‚’é™¤å»ã—ã¦ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸æœ¬æ–‡ã‚’å–å¾—
    const cleanText = this.removeMention(text);
    
    // æ„å›³ã‚’åˆ†æ
    const intent = this.analyzeIntent(cleanText);
    
    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŠ½å‡º
    const parameters = this.extractParameters(cleanText, intent);
    
    return {
      type: 'mention',
      mention,
      originalText: text,
      cleanText,
      intent,
      parameters,
      confidence: this.calculateConfidence(cleanText, intent),
      user
    };
  }
  
  extractMention(text) {
    for (const mention of this.botMentions) {
      if (text.includes(mention)) {
        return mention;
      }
    }
    return null;
  }
  
  removeMention(text) {
    let cleanText = text;
    for (const mention of this.botMentions) {
      cleanText = cleanText.replace(mention, '').trim();
    }
    return cleanText;
  }
  
  analyzeIntent(text) {
    // å„æ„å›³ãƒ‘ã‚¿ãƒ¼ãƒ³ã¨ã®ãƒãƒƒãƒãƒ³ã‚°
    for (const [intent, patterns] of Object.entries(this.intentPatterns)) {
      for (const pattern of patterns) {
        if (pattern.test(text)) {
          return intent;
        }
      }
    }
    
    // ãƒãƒƒãƒã—ãªã„å ´åˆã¯ä¸€èˆ¬çš„ãªä¼šè©±ã¨ã—ã¦å‡¦ç†
    return 'general';
  }
  
  extractParameters(text, intent) {
    const params = {};
    
    switch (intent) {
      case 'shiftQuery':
        params.period = this.extractTimePeriod(text);
        params.date = this.extractSpecificDate(text);
        break;
        
      case 'shiftRequest':
        params.timeRange = this.extractTimeRange(text);
        params.dayPreferences = this.extractDayPreferences(text);
        params.month = this.extractMonth(text);
        break;
        
      case 'changeRequest':
        params.targetDate = this.extractSpecificDate(text);
        params.reason = this.extractReason(text);
        break;
        
      case 'adminAssign':
        params.assignment = this.extractAssignment(text);
        break;
        
      case 'eventManagement':
        params.eventInfo = this.extractEventInfo(text);
        break;
    }
    
    return params;
  }
  
  extractTimePeriod(text) {
    if (text.includes('ä»Šæœˆ') || text.includes('å½“æœˆ')) return 'current_month';
    if (text.includes('æ¥æœˆ')) return 'next_month';
    if (text.includes('ä»Šæ—¥')) return 'today';
    if (text.includes('æ˜æ—¥')) return 'tomorrow';
    if (text.includes('æ¥é€±')) return 'next_week';
    return null;
  }
  
  extractSpecificDate(text) {
    // 1/20, 1æœˆ20æ—¥, æ¥é€±ç«æ›œæ—¥ ãªã©ã®æ—¥ä»˜æŠ½å‡º
    const datePatterns = [
      /(\d+)\/(\d+)/,
      /(\d+)æœˆ(\d+)æ—¥/,
      /(æ¥é€±|ä»Šé€±|å†æ¥é€±)(æœˆ|ç«|æ°´|æœ¨|é‡‘|åœŸ|æ—¥)/
    ];
    
    for (const pattern of datePatterns) {
      const match = text.match(pattern);
      if (match) {
        if (pattern.source.includes('æœˆ') && pattern.source.includes('æ—¥')) {
          const month = match[1].padStart(2, '0');
          const day = match[2].padStart(2, '0');
          return `${new Date().getFullYear()}-${month}-${day}`;
        } else if (pattern.source.includes('/')) {
          const month = match[1].padStart(2, '0');
          const day = match[2].padStart(2, '0');
          return `${new Date().getFullYear()}-${month}-${day}`;
        }
        // ç›¸å¯¾æ—¥ä»˜ï¼ˆæ¥é€±ç«æ›œæ—¥ãªã©ï¼‰ã®å‡¦ç†
        return this.calculateRelativeDate(match[1], match[2]);
      }
    }
    return null;
  }
  
  extractTimeRange(text) {
    const timePattern = /(\d{1,2})æ™‚.*?(\d{1,2})æ™‚/;
    const match = text.match(timePattern);
    
    if (match) {
      return {
        start: `${match[1].padStart(2, '0')}:00`,
        end: `${match[2].padStart(2, '0')}:00`
      };
    }
    return null;
  }
  
  extractDayPreferences(text) {
    const preferences = {};
    
    if (text.includes('å¹³æ—¥')) {
      preferences.weekdays = { available: true };
    }
    
    if (text.includes('åœŸæ—¥')) {
      const isUnavailable = text.includes('ä¼‘ã¿') || text.includes('NG');
      preferences.weekends = { available: !isUnavailable };
    }
    
    return preferences;
  }
  
  extractReason(text) {
    if (text.includes('ä½“èª¿') || text.includes('é¢¨é‚ª') || text.includes('ç†±')) {
      return 'ä½“èª¿ä¸è‰¯';
    }
    if (text.includes('ç”¨äº‹') || text.includes('äºˆå®š')) {
      return 'ç§ç”¨';
    }
    if (text.includes('æ€¥')) {
      return 'æ€¥ç”¨';
    }
    if (text.includes('å®¶æ—') || text.includes('å®¶åº­')) {
      return 'å®¶åº­ã®äº‹æƒ…';
    }
    return 'æœªæŒ‡å®š';
  }
  
  extractAssignment(text) {
    // "ç”°ä¸­ã•ã‚“ã‚’æ´—ã„å ´ã®9æ™‚ã‹ã‚‰17æ™‚ã«é…ç½®" ã®è§£æ
    const assignPattern = /(.*?)ã‚’(.*?)ã®(\d{1,2})æ™‚ã‹ã‚‰(\d{1,2})æ™‚/;
    const match = text.match(assignPattern);
    
    if (match) {
      return {
        name: match[1].replace('ã•ã‚“', ''),
        position: match[2],
        startTime: `${match[3].padStart(2, '0')}:00`,
        endTime: `${match[4].padStart(2, '0')}:00`
      };
    }
    return null;
  }
  
  extractEventInfo(text) {
    // "ãŠç›†ä¼‘ã¿æœŸé–“ã‚’8æœˆ11æ—¥ã‹ã‚‰15æ—¥ã¾ã§ã€ãƒ›ãƒ¼ãƒ«2äººè¿½åŠ ã§è¨­å®š"
    const eventPattern = /(.*?)ã‚’(\d+)æœˆ(\d+)æ—¥ã‹ã‚‰(\d+)æœˆ?(\d+)æ—¥/;
    const match = text.match(eventPattern);
    
    if (match) {
      const startMonth = match[2].padStart(2, '0');
      const startDay = match[3].padStart(2, '0');
      const endMonth = (match[4] || match[2]).padStart(2, '0');
      const endDay = match[5].padStart(2, '0');
      
      return {
        name: match[1],
        startDate: `${new Date().getFullYear()}-${startMonth}-${startDay}`,
        endDate: `${new Date().getFullYear()}-${endMonth}-${endDay}`,
        additionalStaff: this.extractAdditionalStaff(text)
      };
    }
    return null;
  }
  
  extractAdditionalStaff(text) {
    const staffPattern = /(ãƒ›ãƒ¼ãƒ«|æ´—ã„å ´|ãƒ¬ãƒ¼ãƒ³)(\d+)äººè¿½åŠ /;
    const match = text.match(staffPattern);
    
    if (match) {
      const position = this.getPositionId(match[1]);
      const count = parseInt(match[2]);
      return { [position]: count };
    }
    
    return { 'pos_04': 1 }; // ãƒ‡ãƒ•ã‚©ãƒ«ãƒˆã¯ãƒ›ãƒ¼ãƒ«+1äºº
  }
  
  getPositionId(positionName) {
    const mapping = {
      'æ´—ã„å ´': 'pos_01',
      '1ãƒ¬ãƒ¼ãƒ³': 'pos_02',
      '2ãƒ¬ãƒ¼ãƒ³': 'pos_03',
      'ãƒ›ãƒ¼ãƒ«': 'pos_04'
    };
    return mapping[positionName] || 'pos_04';
  }
  
  calculateConfidence(text, intent) {
    // ãƒ†ã‚­ã‚¹ãƒˆã¨æ„å›³ã®ä¸€è‡´åº¦ã‚’è¨ˆç®—
    const patterns = this.intentPatterns[intent] || [];
    let confidence = 0;
    
    for (const pattern of patterns) {
      if (pattern.test(text)) {
        confidence = Math.max(confidence, 0.8);
      }
    }
    
    return confidence;
  }
  
  calculateRelativeDate(period, dayOfWeek) {
    // "æ¥é€±ç«æ›œæ—¥" ãªã©ã®è¨ˆç®—
    const today = new Date();
    const dayMapping = {
      'æœˆ': 1, 'ç«': 2, 'æ°´': 3, 'æœ¨': 4, 'é‡‘': 5, 'åœŸ': 6, 'æ—¥': 0
    };
    
    const targetDay = dayMapping[dayOfWeek];
    if (targetDay === undefined) return null;
    
    let targetDate = new Date(today);
    
    if (period === 'æ¥é€±') {
      targetDate.setDate(today.getDate() + 7);
    } else if (period === 'å†æ¥é€±') {
      targetDate.setDate(today.getDate() + 14);
    }
    
    // æŒ‡å®šæ›œæ—¥ã«èª¿æ•´
    const daysDiff = targetDay - targetDate.getDay();
    targetDate.setDate(targetDate.getDate() + daysDiff);
    
    return targetDate.toISOString().split('T')[0];
  }
}
```

## LINE Bot ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ï¼ˆãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å¯¾å¿œç‰ˆï¼‰

### ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸å‡¦ç†ã®æ”¹è‰¯
```javascript
// api/webhook.jsï¼ˆæ”¹è‰¯ç‰ˆï¼‰
import { MentionParser } from '../lib/nlp/mention-parser.js';
import { ShiftStateManager, SHIFT_STATUS } from '../lib/shift-status.js';
import { ShortageDetector } from '../lib/shortage-detector.js';
import { EventManager } from '../lib/event-manager.js';
import { db } from '../lib/database.js';

export class LineMentionHandler {
  constructor() {
    this.mentionParser = new MentionParser();
    this.stateManager = new ShiftStateManager(db);
    this.shortageDetector = new ShortageDetector(db);
    this.eventManager = new EventManager(db);
  }
  
  async handleMessage(event) {
    const messageText = event.message.text;
    const lineUserId = event.source.userId;
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—
    const user = await db.getUser(lineUserId);
    if (!user) {
      return await this.handleNewUser(event);
    }
    
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³è§£æ
    const parsed = this.mentionParser.parse(messageText, user);
    
    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãŒãªã„å ´åˆã¯æ—¥å¸¸ä¼šè©±ã¨ã—ã¦å‡¦ç†
    if (!parsed) {
      return await this.handleChatMessage(messageText, user, event);
    }
    
    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã‚¢ã‚¯ãƒ†ã‚£ãƒ–æ™‚åˆ»æ›´æ–°
    await db.saveUser(lineUserId, { lastSeenAt: new Date().toISOString() });
    
    try {
      return await this.handleIntent(parsed, event);
    } catch (error) {
      console.error('Intent handling error:', error);
      return await this.replyToUser(event, 
        'ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\n' +
        'ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ã„ãŸã ãã‹ã€é•ã†è¨€ã„æ–¹ã§è©±ã—ã‹ã‘ã¦ãã ã•ã„ã€‚'
      );
    }
  }
  
  async handleIntent(parsed, event) {
    const { intent, parameters, user } = parsed;
    
    switch (intent) {
      case 'shiftQuery':
        return await this.handleShiftQuery(parameters, user, event);
        
      case 'shiftRequest':
        return await this.handleShiftRequest(parameters, user, event);
        
      case 'changeRequest':
        return await this.handleChangeRequest(parameters, user, event);
        
      case 'pdfRequest':
        return await this.handlePdfRequest(parameters, user, event);
        
      case 'noticeQuery':
        return await this.handleNoticeQuery(parameters, user, event);
        
      case 'statusQuery':
        return await this.handleStatusQuery(parameters, user, event);
        
      case 'helpRequest':
        return await this.handleHelpRequest(user, event);
        
      // ç®¡ç†è€…æ©Ÿèƒ½
      case 'adminPreview':
        return await this.handleAdminPreview(parameters, user, event);
        
      case 'adminConflicts':
        return await this.handleAdminConflicts(parameters, user, event);
        
      case 'adminAssign':
        return await this.handleAdminAssign(parameters, user, event);
        
      case 'adminConfirm':
        return await this.handleAdminConfirm(parameters, user, event);
        
      case 'eventManagement':
        return await this.handleEventManagement(parameters, user, event);
        
      default:
        return await this.handleGeneral(parsed, event);
    }
  }
  
  // === æ„å›³åˆ¥ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ ===
  async handleShiftQuery(params, user, event) {
    const period = params.period;
    const specificDate = params.date;
    
    if (specificDate) {
      // ç‰¹å®šæ—¥ã®ã‚·ãƒ•ãƒˆè¡¨ç¤º
      return await this.showDailyShift(specificDate, user, event);
    }
    
    switch (period) {
      case 'today':
        const today = new Date().toISOString().split('T')[0];
        return await this.showDailyShift(today, user, event);
        
      case 'tomorrow':
        const tomorrow = new Date();
        tomorrow.setDate(tomorrow.getDate() + 1);
        return await this.showDailyShift(tomorrow.toISOString().split('T')[0], user, event);
        
      case 'current_month':
        const currentMonth = new Date().toISOString().slice(0, 7);
        return await this.showMonthlyShift(currentMonth, user, event);
        
      case 'next_month':
        const nextMonth = this.getNextMonth();
        return await this.showMonthlyShift(nextMonth, user, event);
        
      default:
        return await this.replyToUser(event, 
          'æœŸé–“ã‚’æŒ‡å®šã—ã¦ãã ã•ã„ã€‚\n\n' +
          'ä¾‹ï¼š\n' +
          '@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä»Šæœˆã®ã‚·ãƒ•ãƒˆ\n' +
          '@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ˜æ—¥ã®ã‚·ãƒ•ãƒˆ\n' +
          '@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ 1æœˆ20æ—¥ã®ã‚·ãƒ•ãƒˆ'
        );
    }
  }
  
  async handleShiftRequest(params, user, event) {
    if (user.role !== 'admin' && user.role !== 'staff') {
      return await this.replyToUser(event, 'âš ï¸ ã‚·ãƒ•ãƒˆæå‡ºæ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
    }
    
    const shiftData = {
      originalText: event.message.text,
      timePreferences: params.timeRange,
      dayPreferences: params.dayPreferences,
      month: params.month || this.getNextMonth()
    };
    
    // ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’ä¿å­˜
    await db.saveShiftRequest(shiftData.month, user.lineUserId, {
      requestText: shiftData.originalText,
      parsedData: shiftData
    });
    
    // ä»®ã‚·ãƒ•ãƒˆã‚’è‡ªå‹•ç”Ÿæˆãƒ»æ›´æ–°
    const previewShifts = await this.stateManager.generatePreviewShift(shiftData.month);
    await this.savePreviewShifts(shiftData.month, previewShifts);
    
    const response = `âœ… ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸï¼
    
ğŸ“… **å¯¾è±¡æœˆ**: ${shiftData.month}
â° **æ™‚é–“**: ${shiftData.timeRange ? `${shiftData.timeRange.start} - ${shiftData.timeRange.end}` : 'æœªæŒ‡å®š'}
ğŸ“‹ **æ›œæ—¥**: ${this.formatDayPreferences(shiftData.dayPreferences)}

ğŸ”„ ä»®ã‚·ãƒ•ãƒˆã«è‡ªå‹•åæ˜ ã—ã¾ã—ãŸã€‚
è²¬ä»»è€…ã«ã‚ˆã‚‹ç¢ºå®šã‚’ãŠå¾…ã¡ãã ã•ã„ã€‚

ã‚·ãƒ•ãƒˆç¢ºèªã¯ã€Œ@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆã€ã§ã§ãã¾ã™ã€‚`;
    
    return await this.replyToUser(event, response);
  }
  
  async handleChangeRequest(params, user, event) {
    if (user.role !== 'admin' && user.role !== 'staff') {
      return await this.replyToUser(event, 'âš ï¸ ã‚·ãƒ•ãƒˆå¤‰æ›´æ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚');
    }
    
    // ä»£æ›¿ä¾é ¼ã¨ã—ã¦ä¿å­˜
    const requestData = {
      requesterId: user.lineUserId,
      targetDate: params.targetDate,
      reason: params.reason,
      originalText: event.message.text,
      status: 'pending'
    };
    
    await db.saveSubstituteRequest(requestData);
    
    // ç®¡ç†è€…ã«é€šçŸ¥
    await this.notifyAdmins(`ğŸ”„ **ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›**

ğŸ‘¤ **ç”³è«‹è€…**: ${user.displayName}ã•ã‚“
ğŸ“… **å¯¾è±¡æ—¥**: ${params.targetDate || 'æœªæŒ‡å®š'}
ğŸ’­ **ç†ç”±**: ${params.reason}
ğŸ“ **è©³ç´°**: ${event.message.text}

@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ äººæ‰‹ä¸è¶³ã®è©³ç´°æ•™ãˆã¦
ã§ç¢ºèªãƒ»èª¿æ•´ã§ãã¾ã™ã€‚`);
    
    const response = `ğŸ”„ ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸ

ğŸ“… **å¯¾è±¡æ—¥**: ${params.targetDate || 'æœªæŒ‡å®š'}
ğŸ’­ **ç†ç”±**: ${params.reason}

è²¬ä»»è€…ã«é€šçŸ¥ã—ã¾ã—ãŸã€‚
ç¢ºèªå¾Œã€èª¿æ•´ã„ãŸã—ã¾ã™ã€‚

æ€¥ãã®å ´åˆã¯ç›´æ¥è²¬ä»»è€…ã«ã‚‚ã”é€£çµ¡ãã ã•ã„ã€‚`;
    
    return await this.replyToUser(event, response);
  }
  
  async handlePdfRequest(params, user, event) {
    const currentMonth = new Date().toISOString().slice(0, 7);
    const baseUrl = process.env.VERCEL_URL || 'https://your-app.vercel.app';
    
    const response = `ğŸ“„ **ã‚·ãƒ•ãƒˆè¡¨ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰**

ğŸ“± **ãƒ–ãƒ©ã‚¦ã‚¶ã§ç¢ºèª**
${baseUrl}/${currentMonth}

ğŸ“„ **PDFãƒ•ã‚¡ã‚¤ãƒ«**
${baseUrl}/api/pdf/${currentMonth}?user=${user.lineUserId}

ğŸ–¼ï¸ **ç”»åƒãƒ•ã‚¡ã‚¤ãƒ«ï¼ˆã‚¹ãƒãƒ›ä¿å­˜ç”¨ï¼‰**
${baseUrl}/api/image/${currentMonth}?user=${user.lineUserId}

ğŸ’¡ ãƒªãƒ³ã‚¯ã‚’ã‚¿ãƒƒãƒ—ã—ã¦ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ã—ã¦ãã ã•ã„ã€‚
â€» ãƒªãƒ³ã‚¯ã¯24æ™‚é–“æœ‰åŠ¹ã§ã™ã€‚`;
    
    return await this.replyToUser(event, response);
  }
  
  async handleHelpRequest(user, event) {
    const isAdmin = user.role === 'admin';
    
    let response = `ğŸ“š **ä½¿ã„æ–¹ã‚¬ã‚¤ãƒ‰**

ğŸ’¬ **åŸºæœ¬çš„ãªä½¿ã„æ–¹**
ç§ã« @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚’ä»˜ã‘ã¦è©±ã—ã‹ã‘ã¦ãã ã•ã„ã€‚

ğŸ” **ã‚·ãƒ•ãƒˆç¢ºèª**
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä»Šæœˆã®ã‚·ãƒ•ãƒˆ
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ˜æ—¥ã®ã‚·ãƒ•ãƒˆæ•™ãˆã¦
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ 1æœˆ20æ—¥ã®ã‚·ãƒ•ãƒˆ

ğŸ“ **ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡º**
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆå¸Œæœ›ã§ã™ã€‚å¹³æ—¥9æ™‚ã‹ã‚‰17æ™‚
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ åœŸæ—¥ä¼‘ã¿å¸Œæœ›ã§ã™

ğŸ”„ **ã‚·ãƒ•ãƒˆå¤‰æ›´**
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥é€±ç«æ›œæ—¥ä»£ã‚ã£ã¦ã‚‚ã‚‰ãˆã¾ã™ã‹
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ€¥ç”¨ã§æ˜æ—¥ãŠä¼‘ã¿ã—ãŸã„ã§ã™

ğŸ“„ **PDFä¿å­˜**
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚·ãƒ•ãƒˆè¡¨ã®PDFæ¬²ã—ã„

ğŸ“¢ **ãŠçŸ¥ã‚‰ã›ç¢ºèª**
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ãŠçŸ¥ã‚‰ã›æ•™ãˆã¦

â“ **ãã®ä»–**
æ™®é€šã«è³ªå•ã—ã¦ã‚‚OKã§ã™ï¼
ã€Œç§ã®ã‚·ãƒ•ãƒˆæå‡ºçŠ¶æ³ã¯ï¼Ÿã€ãªã©`;

    if (isAdmin) {
      response += `

ğŸ‘‘ **ç®¡ç†è€…æ©Ÿèƒ½**
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ä»®ã‚·ãƒ•ãƒˆè¦‹ã›ã¦
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ äººæ‰‹ä¸è¶³ã®è©³ç´°æ•™ãˆã¦
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ç”°ä¸­ã•ã‚“ã‚’æ´—ã„å ´ã®9æ™‚ã‹ã‚‰17æ™‚ã«é…ç½®
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆç¢ºå®šã—ã¦
ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ãŠç›†ä¼‘ã¿ã‚’8æœˆ11æ—¥ã‹ã‚‰15æ—¥ã§è¨­å®š`;
    }
    
    return await this.replyToUser(event, response);
  }
  
  // === ç®¡ç†è€…æ©Ÿèƒ½ ===
  async handleAdminPreview(params, user, event) {
    if (user.role !== 'admin') {
      return await this.replyToUser(event, 'âš ï¸ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚');
    }
    
    const targetMonth = this.getNextMonth();
    
    // ä»®ã‚·ãƒ•ãƒˆã‚’ç”Ÿæˆãƒ»åˆ†æ
    const previewShifts = await this.stateManager.generatePreviewShift(targetMonth);
    const analysis = await this.analyzeMonthlyShortages(targetMonth, previewShifts);
    
    let response = `ğŸ”„ **${targetMonth} ä»®ã‚·ãƒ•ãƒˆçŠ¶æ³**\n\n`;
    
    if (analysis.criticalDays.length > 0) {
      response += `ğŸš¨ **é‡å¤§ãªäººæ‰‹ä¸è¶³** (${analysis.criticalDays.length}æ—¥)\n`;
      for (const day of analysis.criticalDays.slice(0, 3)) {
        response += `ğŸ“… ${day.date}: ${day.shortages.length}ç®‡æ‰€ä¸è¶³\n`;
      }
      if (analysis.criticalDays.length > 3) {
        response += `...ä»–${analysis.criticalDays.length - 3}æ—¥\n`;
      }
      response += `\n`;
    }
    
    if (analysis.warningDays.length > 0) {
      response += `âš ï¸ **è¦æ³¨æ„æ—¥** (${analysis.warningDays.length}æ—¥)\n`;
      for (const day of analysis.warningDays.slice(0, 2)) {
        response += `ğŸ“… ${day.date}: ${day.shortages.length}ç®‡æ‰€ä¸è¶³\n`;
      }
      response += `\n`;
    }
    
    response += `ğŸ“Š **çµ±è¨ˆæƒ…å ±**
ãƒ»ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡º: ${analysis.totalSubmissions}/${analysis.totalStaff}å
ãƒ»äººæ‰‹ä¸è¶³æ—¥æ•°: ${analysis.shortDays}/${analysis.totalDays}æ—¥
ãƒ»è¦èª¿æ•´ç®‡æ‰€: ${analysis.totalConflicts}ç®‡æ‰€

ğŸ’¡ **æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**
è©³ç´°ç¢ºèª: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ äººæ‰‹ä¸è¶³ã®è©³ç´°æ•™ãˆã¦
ã‚·ãƒ•ãƒˆç¢ºå®š: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆç¢ºå®šã—ã¦`;
    
    return await this.replyToUser(event, response);
  }
  
  async handleAdminConfirm(params, user, event) {
    if (user.role !== 'admin') {
      return await this.replyToUser(event, 'âš ï¸ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚');
    }
    
    const targetMonth = this.getNextMonth();
    
    // äººæ‰‹ä¸è¶³ãƒã‚§ãƒƒã‚¯
    const previewShifts = await this.getPreviewShifts(targetMonth);
    const hasShortages = await this.checkCriticalShortages(targetMonth, previewShifts);
    
    if (hasShortages) {
      return await this.replyToUser(event, 
        `âš ï¸ **ç¢ºå®šå‰ã«è¦ç¢ºèª**\n\n` +
        `é‡å¤§ãªäººæ‰‹ä¸è¶³ãŒã‚ã‚Šã¾ã™ã€‚\n` +
        `ã€Œ@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ äººæ‰‹ä¸è¶³ã®è©³ç´°æ•™ãˆã¦ã€ã§ç¢ºèªã—ã¦ãã ã•ã„ã€‚\n\n` +
        `ãã‚Œã§ã‚‚ç¢ºå®šã™ã‚‹å ´åˆã¯ï¼š\n` +
        `ã€Œ@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ äººæ‰‹ä¸è¶³æ‰¿çŸ¥ã§ç¢ºå®šã—ã¦ã€`
      );
    }
    
    // ã‚·ãƒ•ãƒˆç¢ºå®šå‡¦ç†
    await this.confirmShifts(targetMonth, previewShifts, user);
    
    // å…¨ã‚¹ã‚¿ãƒƒãƒ•ã«é€šçŸ¥
    await this.notifyAllStaff(`ğŸ”’ **${targetMonth} ã‚·ãƒ•ãƒˆç¢ºå®šã®ãŠçŸ¥ã‚‰ã›**

ãŠç–²ã‚Œã•ã¾ã§ã™ï¼
${targetMonth} ã®ã‚·ãƒ•ãƒˆãŒç¢ºå®šã—ã¾ã—ãŸã€‚

ğŸ“± ç¢ºèªæ–¹æ³•ï¼š
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆ

ğŸ“„ PDFä¿å­˜ï¼š
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚·ãƒ•ãƒˆè¡¨ã®PDFæ¬²ã—ã„

ä½•ã‹ã”ä¸æ˜ãªç‚¹ãŒã‚ã‚Œã°ã€è²¬ä»»è€…ã¾ã§ã”é€£çµ¡ãã ã•ã„ã€‚`);
    
    return await this.replyToUser(event, 
      `ğŸ”’ **${targetMonth} ã‚·ãƒ•ãƒˆç¢ºå®šå®Œäº†**\n\n` +
      `å…¨ã‚¹ã‚¿ãƒƒãƒ•ã«é€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚\n\n` +
      `ğŸ“Š ç¢ºå®šæ¸ˆã¿ã‚·ãƒ•ãƒˆç¢ºèªï¼š\n` +
      `@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ${targetMonth}ã®ã‚·ãƒ•ãƒˆ`
    );
  }
  
  // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰ ===
  async showDailyShift(date, user, event) {
    const shifts = await db.getShifts(date);
    const userShifts = shifts.filter(s => s.userId === user.lineUserId);
    const positions = await db.getPositions();
    
    if (userShifts.length === 0) {
      return await this.replyToUser(event, 
        `ğŸ“… **${date}** ${this.getDayOfWeek(date)}\n\n` +
        `ãŠç–²ã‚Œã•ã¾ã§ã™ï¼\n` +
        `ã“ã®æ—¥ã¯ãŠä¼‘ã¿ã§ã™ ğŸ˜Š`
      );
    }
    
    let response = `ğŸ“… **${date}** ${this.getDayOfWeek(date)}\n\n`;
    
    for (const shift of userShifts) {
      const position = positions.find(p => p.id === shift.positionId);
      const statusIcon = shift.status === SHIFT_STATUS.CONFIRMED ? 'âœ…' : 'ğŸ”„';
      const statusText = shift.status === SHIFT_STATUS.CONFIRMED ? 'ç¢ºå®š' : 'ä»®';
      
      response += `${statusIcon} **${position.emoji} ${position.name}**\n`;
      response += `â° ${shift.startTime} - ${shift.endTime}\n`;
      response += `ğŸ—“ï¸ ${statusText}ã‚·ãƒ•ãƒˆ\n\n`;
    }
    
    // ä¼‘æ†©æ™‚é–“ã®è¡¨ç¤º
    const totalBreak = userShifts.reduce((sum, shift) => sum + (shift.breakMinutes || 0), 0);
    if (totalBreak > 0) {
      response += `â˜• ä¼‘æ†©æ™‚é–“: ${totalBreak}åˆ†\n\n`;
    }
    
    response += `ğŸ’¡ **å¤‰æ›´å¸Œæœ›ãŒã‚ã‚‹å ´åˆ**\n`;
    response += `@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ${date}ä»£ã‚ã£ã¦ã‚‚ã‚‰ãˆã¾ã™ã‹`;
    
    return await this.replyToUser(event, response);
  }
  
  async showMonthlyShift(month, user, event) {
    const monthlyShifts = await this.getMonthlyShifts(month);
    const userShifts = this.filterUserShifts(monthlyShifts, user.lineUserId);
    const positions = await db.getPositions();
    
    if (Object.keys(userShifts).length === 0) {
      return await this.replyToUser(event, 
        `ğŸ“… **${month}** \n\n` +
        `ã‚·ãƒ•ãƒˆãŒç™»éŒ²ã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚\n\n` +
        `ğŸ’¡ ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’æå‡ºã™ã‚‹å ´åˆï¼š\n` +
        `@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆå¸Œæœ›ã§ã™ã€‚å¹³æ—¥9æ™‚ã‹ã‚‰17æ™‚`
      );
    }
    
    let response = `ğŸ“… **${month} ã‚ãªãŸã®ã‚·ãƒ•ãƒˆ**\n\n`;
    
    // é€±ã”ã¨ã«è¡¨ç¤º
    const weeks = this.groupByWeek(userShifts);
    for (const [weekStart, weekShifts] of Object.entries(weeks)) {
      response += `ğŸ“† **${weekStart}ã®é€±**\n`;
      
      for (const [date, shifts] of Object.entries(weekShifts)) {
        const dayOfWeek = this.getDayOfWeek(date);
        
        if (shifts.length === 0) {
          response += `${date}(${dayOfWeek}): ãŠä¼‘ã¿\n`;
        } else {
          for (const shift of shifts) {
            const position = positions.find(p => p.id === shift.positionId);
            const statusIcon = shift.status === SHIFT_STATUS.CONFIRMED ? 'âœ…' : 'ğŸ”„';
            response += `${date}(${dayOfWeek}): ${statusIcon}${position.emoji}${shift.startTime}-${shift.endTime}\n`;
          }
        }
      }
      response += `\n`;
    }
    
    // çµ±è¨ˆæƒ…å ±
    const totalShifts = Object.values(userShifts).flat().length;
    const totalHours = this.calculateTotalHours(userShifts);
    
    response += `ğŸ“Š **æœˆé–“çµ±è¨ˆ**\n`;
    response += `å‡ºå‹¤æ—¥æ•°: ${totalShifts}æ—¥\n`;
    response += `ç·å‹¤å‹™æ™‚é–“: ${totalHours}æ™‚é–“\n\n`;
    
    response += `ğŸ“„ PDFä¿å­˜: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ PDFæ¬²ã—ã„`;
    
    return await this.replyToUser(event, response);
  }
  
  async handleGeneral(parsed, event) {
    const { cleanText, user } = parsed;
    
    // ã‚ˆãã‚ã‚‹è³ªå•ã¸ã®è‡ªå‹•å¿œç­”
    if (cleanText.includes('ã‚ã‚ŠãŒã¨ã†') || cleanText.includes('åŠ©ã‹ã‚Š')) {
      return await this.replyToUser(event, 
        'ã©ã†ã„ãŸã—ã¾ã—ã¦ï¼ğŸ˜Š\n\n' +
        'ã¾ãŸä½•ã‹ã‚ã‚Œã° @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚’ä»˜ã‘ã¦è©±ã—ã‹ã‘ã¦ãã ã•ã„ã€‚'
      );
    }
    
    if (cleanText.includes('ãŠã¯ã‚ˆã†') || cleanText.includes('ã“ã‚“ã«ã¡ã¯') || cleanText.includes('ãŠç–²ã‚Œ')) {
      const greeting = this.getTimeBasedGreeting();
      return await this.replyToUser(event, 
        `${greeting}ã€${user.displayName}ã•ã‚“ï¼\n\n` +
        'ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ\n' +
        'ä½¿ã„æ–¹ãŒåˆ†ã‹ã‚‰ãªã„å ´åˆã¯ã€Œ@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä½¿ã„æ–¹æ•™ãˆã¦ã€ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚'
      );
    }
    
    if (cleanText.includes('å¿™ã—ã„') || cleanText.includes('å¤§å¤‰')) {
      return await this.replyToUser(event, 
        'ãŠç–²ã‚Œã•ã¾ã§ã™ï¼ğŸ˜Š\n\n' +
        'ã‚·ãƒ•ãƒˆã®ç¢ºèªã‚„å¤‰æ›´å¸Œæœ›ãªã©ã€ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ãŒã‚ã‚Œã°é æ…®ãªããŠå£°ã‹ã‘ãã ã•ã„ã€‚\n\n' +
        'ä¾‹ï¼š@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ˜æ—¥ã®ã‚·ãƒ•ãƒˆæ•™ãˆã¦'
      );
    }
    
    // ãã®ä»–ã®ä¸€èˆ¬çš„ãªå¿œç­”
    return await this.replyToUser(event, 
      'ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚\n' +
      'ã†ã¾ãç†è§£ã§ãã¾ã›ã‚“ã§ã—ãŸã€‚\n\n' +
      'ğŸ’¡ **ã“ã‚“ãªæ„Ÿã˜ã§è©±ã—ã‹ã‘ã¦ãã ã•ã„ï¼š**\n' +
      'ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä»Šæœˆã®ã‚·ãƒ•ãƒˆ\n' +
      'ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆå¸Œæœ›ã§ã™\n' +
      'ãƒ»@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä½¿ã„æ–¹æ•™ãˆã¦\n\n' +
      'ãŠå›°ã‚Šã®å ´åˆã¯è²¬ä»»è€…ã«ã”ç›¸è«‡ãã ã•ã„ã€‚'
    );
  }
  
  // === ãƒ˜ãƒ«ãƒ‘ãƒ¼ãƒ¡ã‚½ãƒƒãƒ‰ ===
  formatDayPreferences(dayPrefs) {
    if (!dayPrefs) return 'æœªæŒ‡å®š';
    
    const parts = [];
    if (dayPrefs.weekdays?.available) parts.push('å¹³æ—¥OK');
    if (dayPrefs.weekends?.available === false) parts.push('åœŸæ—¥ä¼‘ã¿å¸Œæœ›');
    if (dayPrefs.weekends?.available === true) parts.push('åœŸæ—¥OK');
    
    return parts.length > 0 ? parts.join(', ') : 'æœªæŒ‡å®š';
  }
  
  getTimeBasedGreeting() {
    const hour = new Date().getHours();
    if (hour < 10) return 'ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™';
    if (hour < 18) return 'ãŠç–²ã‚Œã•ã¾ã§ã™';
    return 'ãŠç–²ã‚Œã•ã¾ã§ã—ãŸ';
  }
  
  getDayOfWeek(date) {
    const days = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
    return days[new Date(date).getDay()];
  }
  
  getNextMonth() {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    return nextMonth.toISOString().slice(0, 7);
  }
  
  async replyToUser(event, message) {
    // LINE Messaging API ã§ã®è¿”ä¿¡å®Ÿè£…
    // å®Ÿéš›ã®å®Ÿè£…ã§ã¯ @line/bot-sdk ã‚’ä½¿ç”¨
    console.log(`Reply to ${event.source.userId}: ${message}`);
    
    // å®Ÿè£…ä¾‹ï¼ˆline-sdkä½¿ç”¨æ™‚ï¼‰:
    // return lineClient.replyMessage(event.replyToken, {
    //   type: 'text',
    //   text: message
    // });
  }
  
  async notifyAdmins(message) {
    const users = await db.getActiveUsers();
    const adminUsers = users.filter(user => user.role === 'admin');
    
    for (const admin of adminUsers) {
      // ãƒ—ãƒƒã‚·ãƒ¥ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã§ç®¡ç†è€…ã«é€šçŸ¥
      console.log(`Push message to admin ${admin.lineUserId}: ${message}`);
    }
  }
  
  async notifyAllStaff(message) {
    const users = await db.getActiveUsers();
    
    for (const user of users) {
      console.log(`Push message to ${user.lineUserId}: ${message}`);
    }
  }
}
```

## Webhook ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆå®Ÿè£…

### LINE Webhook ã®å®Œå…¨å®Ÿè£…
```javascript
// api/webhook.jsï¼ˆãƒ¡ã‚¤ãƒ³ï¼‰
import { LineMentionHandler } from '../lib/line-mention-handler.js';
import { Client } from '@line/bot-sdk';
import crypto from 'crypto';

const config = {
  channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN,
  channelSecret: process.env.LINE_CHANNEL_SECRET,
};

const client = new Client(config);
const mentionHandler = new LineMentionHandler();

export default async function handler(req, res) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  // LINEç½²åæ¤œè¨¼
  const signature = req.headers['x-line-signature'];
  const body = JSON.stringify(req.body);

  if (!validateSignature(body, signature)) {
    return res.status(401).json({ error: 'Invalid signature' });
  }

  const events = req.body.events;

  try {
    await Promise.all(events.map(async (event) => {
      if (event.type === 'message' && event.message.type === 'text') {
        await mentionHandler.handleMessage(event);
      } else if (event.type === 'memberJoined') {
        await handleMemberJoined(event);
      } else if (event.type === 'memberLeft') {
        await handleMemberLeft(event);
      }
    }));

    res.status(200).json({ success: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

function validateSignature(body, signature) {
  const hash = crypto
    .createHmac('SHA256', process.env.LINE_CHANNEL_SECRET)
    .update(body)
    .digest('base64');
  
  return hash === signature;
}

async function handleMemberJoined(event) {
  // ã‚°ãƒ«ãƒ¼ãƒ—å‚åŠ æ™‚ã®è‡ªå‹•ãƒ¦ãƒ¼ã‚¶ãƒ¼ç™»éŒ²
  for (const member of event.joined.members) {
    if (member.type === 'user') {
      try {
        const profile = await client.getProfile(member.userId);
        
        await db.saveUser(member.userId, {
          displayName: profile.displayName,
          role: 'staff',
          isActive: true,
          joinedAt: new Date().toISOString()
        });
        
        // ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        const welcomeMessage = `${profile.displayName}ã•ã‚“ã€ã‚ˆã†ã“ãï¼ğŸ‘‹

ã‚·ãƒ•ãƒˆç®¡ç†ãƒœãƒƒãƒˆã§ã™ã€‚
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚’ä»˜ã‘ã¦è©±ã—ã‹ã‘ã¦ãã ã•ã„ã€‚

ğŸ’¡ **ã¾ãšã¯ã“ã¡ã‚‰ã‚’ãŠè©¦ã—ãã ã•ã„ï¼š**
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä½¿ã„æ–¹æ•™ãˆã¦

ä½•ã‹ã”ä¸æ˜ãªç‚¹ãŒã‚ã‚Œã°ã€ãŠæ°—è»½ã«ãŠå£°ã‹ã‘ãã ã•ã„ï¼`;

        await client.pushMessage(member.userId, {
          type: 'text',
          text: welcomeMessage
        });
        
      } catch (error) {
        console.error('Failed to handle member joined:', error);
      }
    }
  }
}

async function handleMemberLeft(event) {
  // ã‚°ãƒ«ãƒ¼ãƒ—é€€å‡ºæ™‚ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼ç„¡åŠ¹åŒ–
  for (const member of event.left.members) {
    if (member.type === 'user') {
      const user = await db.getUser(member.userId);
      if (user) {
        await db.saveUser(member.userId, {
          ...user,
          isActive: false,
          leftAt: new Date().toISOString()
        });
      }
    }
  }
}
```

## ä½¿ç”¨ä¾‹ã¨ãƒ¬ã‚¹ãƒãƒ³ã‚¹ä¾‹

### ä¸€èˆ¬ã‚¹ã‚¿ãƒƒãƒ•ã®åˆ©ç”¨ä¾‹
```
ã‚¹ã‚¿ãƒƒãƒ•: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™

Bot: ãŠã¯ã‚ˆã†ã”ã–ã„ã¾ã™ã€ç”°ä¸­ã•ã‚“ï¼ğŸ˜Š

ä½•ã‹ãŠæ‰‹ä¼ã„ã§ãã‚‹ã“ã¨ã¯ã‚ã‚Šã¾ã™ã‹ï¼Ÿ
ä½¿ã„æ–¹ãŒåˆ†ã‹ã‚‰ãªã„å ´åˆã¯ã€Œ@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ä½¿ã„æ–¹æ•™ãˆã¦ã€ã‚’ãŠè©¦ã—ãã ã•ã„ã€‚

---

ã‚¹ã‚¿ãƒƒãƒ•: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆå¸Œæœ›ã§ã™ã€‚å¹³æ—¥ã¯9æ™‚ã‹ã‚‰17æ™‚ã§ã€åœŸæ—¥ã¯ä¼‘ã¿å¸Œæœ›

Bot: âœ… ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸï¼

ğŸ“… **å¯¾è±¡æœˆ**: 2025-02
â° **æ™‚é–“**: 09:00 - 17:00
ğŸ“‹ **æ›œæ—¥**: å¹³æ—¥OK, åœŸæ—¥ä¼‘ã¿å¸Œæœ›

ğŸ”„ ä»®ã‚·ãƒ•ãƒˆã«è‡ªå‹•åæ˜ ã—ã¾ã—ãŸã€‚
è²¬ä»»è€…ã«ã‚ˆã‚‹ç¢ºå®šã‚’ãŠå¾…ã¡ãã ã•ã„ã€‚

ã‚·ãƒ•ãƒˆç¢ºèªã¯ã€Œ@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆã€ã§ã§ãã¾ã™ã€‚

---

ã‚¹ã‚¿ãƒƒãƒ•: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥é€±ã®ç«æ›œæ—¥ä»£ã‚ã£ã¦ã‚‚ã‚‰ãˆã¾ã™ã‹

Bot: ğŸ”„ ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸ

ğŸ“… **å¯¾è±¡æ—¥**: 2025-01-21
ğŸ’­ **ç†ç”±**: æœªæŒ‡å®š

è²¬ä»»è€…ã«é€šçŸ¥ã—ã¾ã—ãŸã€‚
ç¢ºèªå¾Œã€èª¿æ•´ã„ãŸã—ã¾ã™ã€‚

æ€¥ãã®å ´åˆã¯ç›´æ¥è²¬ä»»è€…ã«ã‚‚ã”é€£çµ¡ãã ã•ã„ã€‚
```

### ç®¡ç†è€…ã®åˆ©ç”¨ä¾‹
```
ç®¡ç†è€…: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ä»®ã‚·ãƒ•ãƒˆè¦‹ã›ã¦

Bot: ğŸ”„ **2025-02 ä»®ã‚·ãƒ•ãƒˆçŠ¶æ³**

ğŸš¨ **é‡å¤§ãªäººæ‰‹ä¸è¶³** (3æ—¥)
ğŸ“… 2025-02-05: 2ç®‡æ‰€ä¸è¶³
ğŸ“… 2025-02-12: 3ç®‡æ‰€ä¸è¶³
ğŸ“… 2025-02-19: 1ç®‡æ‰€ä¸è¶³

âš ï¸ **è¦æ³¨æ„æ—¥** (5æ—¥)
ğŸ“… 2025-02-08: 1ç®‡æ‰€ä¸è¶³
ğŸ“… 2025-02-15: 1ç®‡æ‰€ä¸è¶³

ğŸ“Š **çµ±è¨ˆæƒ…å ±**
ãƒ»ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡º: 8/12å
ãƒ»äººæ‰‹ä¸è¶³æ—¥æ•°: 8/28æ—¥
ãƒ»è¦èª¿æ•´ç®‡æ‰€: 15ç®‡æ‰€

ğŸ’¡ **æ¬¡ã®ã‚¢ã‚¯ã‚·ãƒ§ãƒ³**
è©³ç´°ç¢ºèª: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ äººæ‰‹ä¸è¶³ã®è©³ç´°æ•™ãˆã¦
ã‚·ãƒ•ãƒˆç¢ºå®š: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆç¢ºå®šã—ã¦

---

ç®¡ç†è€…: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ 2æœˆ5æ—¥ã€ç”°ä¸­ã•ã‚“ã‚’æ´—ã„å ´ã®9æ™‚ã‹ã‚‰17æ™‚ã«é…ç½®

Bot: âœ… ã‚·ãƒ•ãƒˆèª¿æ•´å®Œäº†

ğŸ“… **æ—¥ä»˜**: 2025-02-05
ğŸ‘¤ **ã‚¹ã‚¿ãƒƒãƒ•**: ç”°ä¸­ã•ã‚“
ğŸ“ **ãƒã‚¸ã‚·ãƒ§ãƒ³**: æ´—ã„å ´
â° **æ™‚é–“**: 09:00 - 17:00

ä»®ã‚·ãƒ•ãƒˆã‚’æ›´æ–°ã—ã¾ã—ãŸã€‚
ç”°ä¸­ã•ã‚“ã«å¤‰æ›´ã‚’é€šçŸ¥ã—ã¾ã—ãŸã€‚
```

ã“ã®æ”¹è‰¯ã«ã‚ˆã‚Šã€ãƒ¦ãƒ¼ã‚¶ãƒ¼ã¯è‡ªç„¶ãªä¼šè©±ã§ã‚·ãƒ•ãƒˆç®¡ç†ãŒã§ãã‚‹ã‚ˆã†ã«ãªã‚Šã€ä½¿ã„ã‚„ã™ã•ãŒå¤§å¹…ã«å‘ä¸Šã—ã¾ã™ï¼## LINE Bot ãƒãƒ³ãƒ‰ãƒ©ãƒ¼å®Ÿè£…

### ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
```# LINE Bot ã‚³ãƒãƒ³ãƒ‰ä½“ç³»ã¨ API è¨­è¨ˆ

## LINE Bot ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§

### ä¸€èˆ¬ã‚¹ã‚¿ãƒƒãƒ•ç”¨ã‚³ãƒãƒ³ãƒ‰ï¼ˆæ¨©é™åˆ¶é™ï¼‰

#### ã‚·ãƒ•ãƒˆé–¢é€£
| ã‚³ãƒãƒ³ãƒ‰ | èª¬æ˜ | ä½¿ç”¨ä¾‹ | ãƒ¬ã‚¹ãƒãƒ³ã‚¹ |
|---------|------|--------|-----------|
| **è‡ªç„¶è¨€èª** | ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡º | `æ¥æœˆå¸Œæœ›ã§ã™ã€‚å¹³æ—¥9-17æ™‚ã€åœŸæ—¥ä¼‘ã¿` | `âœ… ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸï¼ˆä»®ã‚·ãƒ•ãƒˆã«åæ˜ ï¼‰` |
| **è‡ªç„¶è¨€èª** | ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ› | `æ¥é€±ç«æ›œæ—¥ã€ä»£ã‚ã£ã¦ã‚‚ã‚‰ãˆã¾ã›ã‚“ã‹ï¼Ÿ` | `ğŸ”„ ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸ` |
| `/shift` | è‡ªåˆ†ã®ã‚·ãƒ•ãƒˆç¢ºèª | `/shift` | ä»Šæœˆã®ã‚·ãƒ•ãƒˆè¡¨ç¤ºï¼ˆä»®ãƒ»ç¢ºå®šåŒºåˆ¥ï¼‰ |
| `/shift æ˜æ—¥` | ç‰¹å®šæ—¥ã®ã‚·ãƒ•ãƒˆç¢ºèª | `/shift 1/20` | æŒ‡å®šæ—¥ã®ã‚·ãƒ•ãƒˆè¡¨ç¤º |
| `/pdf` | PDFä¿å­˜ãƒªãƒ³ã‚¯ | `/pdf` | PDFãƒ»ç”»åƒãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰ãƒªãƒ³ã‚¯ |

#### æƒ…å ±ç¢ºèªã®ã¿
| ã‚³ãƒãƒ³ãƒ‰ | èª¬æ˜ | ä½¿ç”¨ä¾‹ | ãƒ¬ã‚¹ãƒãƒ³ã‚¹ |
|---------|------|--------|-----------|
| `/help` | ãƒ˜ãƒ«ãƒ—è¡¨ç¤º | `/help` | ä½¿ç”¨å¯èƒ½ã‚³ãƒãƒ³ãƒ‰ä¸€è¦§ |
| `/notice` | å…±æœ‰äº‹é …ç¢ºèª | `/notice` | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãªå…±æœ‰äº‹é …è¡¨ç¤º |
| `/status` | æå‡ºçŠ¶æ³ç¢ºèª | `/status` | è‡ªåˆ†ã®ã‚·ãƒ•ãƒˆæå‡ºçŠ¶æ³ |

### ç®¡ç†è€…å°‚ç”¨ã‚³ãƒãƒ³ãƒ‰ï¼ˆè²¬ä»»è€…æ¨©é™ï¼‰

#### ã‚·ãƒ•ãƒˆç®¡ç†ãƒ»ç¢ºå®š
| ã‚³ãƒãƒ³ãƒ‰ | èª¬æ˜ | ä½¿ç”¨ä¾‹ | ãƒ¬ã‚¹ãƒãƒ³ã‚¹ |
|---------|------|--------|-----------|
| `/preview` | ä»®ã‚·ãƒ•ãƒˆç¢ºèª | `/preview æ¥æœˆ` | ä»®ã‚·ãƒ•ãƒˆè¡¨ç¤ºï¼ˆåã‚Šæ¤œçŸ¥ä»˜ãï¼‰ |
| `/conflicts` | åã‚Šãƒ»ä¸è¶³æ¤œçŸ¥ | `/conflicts` | äººæ‰‹ä¸è¶³ãƒ»åã‚Šç®‡æ‰€ã®è©³ç´°è¡¨ç¤º |
| `/assign` | æ‰‹å‹•ã‚·ãƒ•ãƒˆèª¿æ•´ | `/assign 1/20 ç”°ä¸­ æ´—ã„å ´ 9-17` | ã‚·ãƒ•ãƒˆã‚’èª¿æ•´ã—ã¾ã—ãŸ |
| `/confirm` | ã‚·ãƒ•ãƒˆç¢ºå®š | `/confirm æ¥æœˆ` | ğŸ”’ æ¥æœˆã®ã‚·ãƒ•ãƒˆã‚’ç¢ºå®šã—ã¾ã—ãŸ |
| `/reopen` | ã‚·ãƒ•ãƒˆå†ç·¨é›† | `/reopen æ¥æœˆ` | ã‚·ãƒ•ãƒˆã‚’ç·¨é›†å¯èƒ½ã«æˆ»ã—ã¾ã—ãŸ |

#### ç‰¹åˆ¥æœŸé–“ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®š
| ã‚³ãƒãƒ³ãƒ‰ | èª¬æ˜ | ä½¿ç”¨ä¾‹ | ãƒ¬ã‚¹ãƒãƒ³ã‚¹ |
|---------|------|--------|-----------|
| `/event add` | ç‰¹åˆ¥æœŸé–“è¿½åŠ  | `/event add ãŠç›†ä¼‘ã¿ 8/11-8/15 +2` | ç‰¹åˆ¥æœŸé–“ã‚’è¨­å®šã—ã¾ã—ãŸ |
| `/event list` | ç‰¹åˆ¥æœŸé–“ä¸€è¦§ | `/event list` | è¨­å®šæ¸ˆã¿ç‰¹åˆ¥æœŸé–“è¡¨ç¤º |
| `/event remove` | ç‰¹åˆ¥æœŸé–“å‰Šé™¤ | `/event remove ãŠç›†ä¼‘ã¿` | ç‰¹åˆ¥æœŸé–“ã‚’å‰Šé™¤ã—ã¾ã—ãŸ |
| `/holiday set` | å‹•çš„é€£ä¼‘è¨­å®š | `/holiday set GW 2025/4/29-5/5` | é€£ä¼‘æœŸé–“ã‚’è¨­å®šã—ã¾ã—ãŸ |

#### ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†
| ã‚³ãƒãƒ³ãƒ‰ | èª¬æ˜ | ä½¿ç”¨ä¾‹ | ãƒ¬ã‚¹ãƒãƒ³ã‚¹ |
|---------|------|--------|-----------|
| `/admin setup` | åˆæœŸã‚»ãƒƒãƒˆã‚¢ãƒƒãƒ— | `/admin setup` | ç®¡ç†è€…æ¨©é™è¨­å®šå®Œäº† |
| `/config` | è¨­å®šå¤‰æ›´ | `/config å–¶æ¥­æ™‚é–“ 9:00-22:00` | è¨­å®šã‚’æ›´æ–°ã—ã¾ã—ãŸ |
| `/users` | ãƒ¦ãƒ¼ã‚¶ãƒ¼ä¸€è¦§ | `/users` | ã‚¢ã‚¯ãƒ†ã‚£ãƒ–ãƒ¦ãƒ¼ã‚¶ãƒ¼è¡¨ç¤º |
| `/summary` | æå‡ºçŠ¶æ³ç¢ºèª | `/summary` | å…¨ã‚¹ã‚¿ãƒƒãƒ•ã®æå‡ºçŠ¶æ³ |

#### å…±æœ‰äº‹é …ç®¡ç†
| ã‚³ãƒãƒ³ãƒ‰ | èª¬æ˜ | ä½¿ç”¨ä¾‹ | ãƒ¬ã‚¹ãƒãƒ³ã‚¹ |
|---------|------|--------|-----------|
| `/notice add` | å…±æœ‰äº‹é …è¿½åŠ  | `/notice add æ©Ÿæ¢°æ•…éšœ 2ãƒ¬ãƒ¼ãƒ³é£Ÿæ´—æ©Ÿæ•…éšœä¸­` | å…±æœ‰äº‹é …ã‚’è¿½åŠ ã—ã¾ã—ãŸ |
| `/notice list` | å…±æœ‰äº‹é …ä¸€è¦§ | `/notice list` | å…¨å…±æœ‰äº‹é …è¡¨ç¤º |
| `/notice close` | å…±æœ‰äº‹é …çµ‚äº† | `/notice close notice_001` | å…±æœ‰äº‹é …ã‚’çµ‚äº†ã—ã¾ã—ãŸ |

## ã‚·ãƒ•ãƒˆçŠ¶æ…‹ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

### ã‚·ãƒ•ãƒˆçŠ¶æ…‹ã®å®šç¾©
```javascript
// lib/shift-status.js
export const SHIFT_STATUS = {
  DRAFT: 'draft',           // å¸Œæœ›æå‡ºæ®µéšï¼ˆä»®ã‚·ãƒ•ãƒˆï¼‰
  PREVIEW: 'preview',       // è²¬ä»»è€…ç¢ºèªæ®µéšï¼ˆèª¿æ•´å¯èƒ½ï¼‰
  CONFIRMED: 'confirmed',   // ç¢ºå®šæ¸ˆã¿ï¼ˆå¤‰æ›´ã«ã¯ç†ç”±ãŒå¿…è¦ï¼‰
  LOCKED: 'locked'          // å®Œå…¨ç¢ºå®šï¼ˆç·Šæ€¥æ™‚ã®ã¿å¤‰æ›´å¯ï¼‰
};

export class ShiftStateManager {
  constructor(db) {
    this.db = db;
  }
  
  // ä»®ã‚·ãƒ•ãƒˆç”Ÿæˆï¼ˆå¸Œæœ›ã‚’ãã®ã¾ã¾åæ˜ ï¼‰
  async generatePreviewShift(month) {
    const requests = await this.db.getShiftRequests(month);
    const positions = await this.db.getPositions();
    const previewShifts = {};
    
    // å„ã‚¹ã‚¿ãƒƒãƒ•ã®å¸Œæœ›ã‚’ãã®ã¾ã¾ä»®ã‚·ãƒ•ãƒˆã«åæ˜ 
    for (const [userId, request] of Object.entries(requests)) {
      const parsedData = request.parsedData;
      
      // æœˆã®å„æ—¥ã«ã¤ã„ã¦å‡¦ç†
      const daysInMonth = this.getDaysInMonth(month);
      for (let day = 1; day <= daysInMonth; day++) {
        const date = `${month}-${day.toString().padStart(2, '0')}`;
        const dayOfWeek = new Date(date).getDay();
        
        if (!previewShifts[date]) previewShifts[date] = [];
        
        // å¹³æ—¥/åœŸæ—¥ã®å¸Œæœ›ã«åŸºã¥ã„ã¦ã‚·ãƒ•ãƒˆç”Ÿæˆ
        let shouldWork = false;
        let timeRange = null;
        
        if (dayOfWeek >= 1 && dayOfWeek <= 5 && parsedData.weekdays?.available) {
          shouldWork = true;
          timeRange = parsedData.weekdays;
        } else if ((dayOfWeek === 0 || dayOfWeek === 6) && parsedData.weekends?.available) {
          shouldWork = true;
          timeRange = parsedData.weekends;
        }
        
        if (shouldWork && timeRange) {
          // ä»®ã®ãƒã‚¸ã‚·ãƒ§ãƒ³å‰²å½“ï¼ˆå¾Œã§èª¿æ•´ï¼‰
          const position = positions[0]; // æš«å®šçš„ã«æœ€åˆã®ãƒã‚¸ã‚·ãƒ§ãƒ³
          
          previewShifts[date].push({
            id: `preview_${Date.now()}_${Math.random().toString(36).substr(2, 9)}`,
            userId,
            positionId: position.id,
            startTime: timeRange.preferredStart || '09:00',
            endTime: timeRange.preferredEnd || '17:00',
            status: SHIFT_STATUS.DRAFT,
            isPreview: true,
            createdAt: new Date().toISOString()
          });
        }
      }
    }
    
    return previewShifts;
  }
  
  getDaysInMonth(month) {
    const [year, monthNum] = month.split('-');
    return new Date(year, monthNum, 0).getDate();
  }
}
```

## åã‚Šæ¤œçŸ¥ãƒ»äººæ‰‹ä¸è¶³æ¤œçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

### ä¸è¶³æ¤œçŸ¥ã‚¨ãƒ³ã‚¸ãƒ³
```javascript
// lib/shortage-detector.js
export class ShortageDetector {
  constructor(db) {
    this.db = db;
  }
  
  async analyzeShiftCoverage(date, shifts) {
    const analysis = {
      date,
      shortages: [],
      overages: [],
      warnings: [],
      severity: 'normal' // 'normal', 'warning', 'critical'
    };
    
    // åŸºæœ¬å¿…è¦äººæ•°ã‚’å–å¾—
    const baseRequirements = await this.getBaseRequirements();
    
    // ç‰¹åˆ¥æœŸé–“ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆã®è¿½åŠ äººæ•°ã‚’å–å¾—
    const eventRequirements = await this.getEventRequirements(date);
    
    // æ™‚é–“å¸¯åˆ¥ã®äººå“¡é…ç½®ã‚’è¨ˆç®—
    const hourlyStaffing = this.calculateHourlyStaffing(shifts);
    
    // å¿…è¦äººæ•°ã¨å®Ÿéš›ã®äººæ•°ã‚’æ¯”è¼ƒ
    for (let hour = 9; hour < 22; hour++) {
      const timeSlot = `${hour.toString().padStart(2, '0')}:00`;
      const actualStaff = hourlyStaffing[timeSlot] || {};
      const requiredStaff = this.calculateRequiredStaff(hour, baseRequirements, eventRequirements);
      
      for (const position of await this.db.getPositions()) {
        const actual = actualStaff[position.id] || 0;
        const required = requiredStaff[position.id] || 1;
        
        if (actual < required) {
          analysis.shortages.push({
            time: timeSlot,
            position: position.name,
            positionId: position.id,
            required,
            actual,
            shortage: required - actual
          });
        } else if (actual > required + 1) {
          analysis.overages.push({
            time: timeSlot,
            position: position.name,
            positionId: position.id,
            required,
            actual,
            overage: actual - required
          });
        }
      }
    }
    
    // é‡è¦åº¦åˆ¤å®š
    if (analysis.shortages.length > 0) {
      const criticalShortages = analysis.shortages.filter(s => s.shortage >= 2);
      if (criticalShortages.length > 0) {
        analysis.severity = 'critical';
      } else {
        analysis.severity = 'warning';
      }
    }
    
    return analysis;
  }
  
  calculateHourlyStaffing(shifts) {
    const staffing = {};
    
    for (const shift of shifts) {
      const startHour = parseInt(shift.startTime.split(':')[0]);
      const endHour = parseInt(shift.endTime.split(':')[0]);
      
      for (let hour = startHour; hour < endHour; hour++) {
        const timeSlot = `${hour.toString().padStart(2, '0')}:00`;
        if (!staffing[timeSlot]) staffing[timeSlot] = {};
        if (!staffing[timeSlot][shift.positionId]) staffing[timeSlot][shift.positionId] = 0;
        
        staffing[timeSlot][shift.positionId]++;
      }
    }
    
    return staffing;
  }
  
  async getBaseRequirements() {
    // åŸºæœ¬çš„ãªæ™‚é–“å¸¯åˆ¥å¿…è¦äººæ•°
    return {
      'pos_01': 1, // æ´—ã„å ´
      'pos_02': 1, // 1ãƒ¬ãƒ¼ãƒ³
      'pos_03': 1, // 2ãƒ¬ãƒ¼ãƒ³
      'pos_04': 2  // ãƒ›ãƒ¼ãƒ«
    };
  }
  
  async getEventRequirements(date) {
    const settings = await this.db.getSettings();
    const events = settings.specialEvents || [];
    
    for (const event of events) {
      if (date >= event.startDate && date <= event.endDate) {
        return event.additionalStaff || {};
      }
    }
    
    return {};
  }
  
  calculateRequiredStaff(hour, base, event) {
    const required = { ...base };
    
    // æ™‚é–“å¸¯åˆ¥èª¿æ•´ï¼ˆæ˜¼æ™‚ãƒ»å¤•æ–¹ã¯å¤šã‚ï¼‰
    const timeMultiplier = this.getTimeMultiplier(hour);
    
    for (const [positionId, count] of Object.entries(required)) {
      required[positionId] = Math.ceil(count * timeMultiplier);
      
      // ã‚¤ãƒ™ãƒ³ãƒˆæœŸé–“ã®è¿½åŠ äººæ•°
      if (event[positionId]) {
        required[positionId] += event[positionId];
      }
    }
    
    return required;
  }
  
  getTimeMultiplier(hour) {
    // æ˜¼æ™‚(11-14æ™‚)ã¨å¤•æ–¹(17-20æ™‚)ã¯1.5å€
    if ((hour >= 11 && hour <= 14) || (hour >= 17 && hour <= 20)) {
      return 1.5;
    }
    return 1.0;
  }
}
```

## ç‰¹åˆ¥æœŸé–“ãƒ»ã‚¤ãƒ™ãƒ³ãƒˆç®¡ç†

### ã‚¤ãƒ™ãƒ³ãƒˆè¨­å®šã‚·ã‚¹ãƒ†ãƒ 
```javascript
// lib/event-manager.js
export class EventManager {
  constructor(db) {
    this.db = db;
  }
  
  async addSpecialEvent(name, startDate, endDate, additionalStaff, description) {
    const settings = await this.db.getSettings();
    if (!settings.specialEvents) settings.specialEvents = [];
    
    const event = {
      id: `event_${Date.now()}`,
      name,
      startDate,
      endDate,
      additionalStaff, // { pos_01: 1, pos_04: 2 } å½¢å¼
      description,
      createdAt: new Date().toISOString(),
      isActive: true
    };
    
    settings.specialEvents.push(event);
    await this.db.setSetting('specialEvents', settings.specialEvents);
    
    return event;
  }
  
  async setDynamicHoliday(name, year, dates) {
    const settings = await this.db.getSettings();
    if (!settings.dynamicHolidays) settings.dynamicHolidays = {};
    
    settings.dynamicHolidays[year] = settings.dynamicHolidays[year] || {};
    settings.dynamicHolidays[year][name] = {
      dates,
      additionalStaff: { pos_04: 1 }, // ãƒ›ãƒ¼ãƒ«+1äºº
      createdAt: new Date().toISOString()
    };
    
    await this.db.setSetting('dynamicHolidays', settings.dynamicHolidays);
    
    return settings.dynamicHolidays[year][name];
  }
  
  async getActiveEvents(date) {
    const settings = await this.db.getSettings();
    const events = settings.specialEvents || [];
    
    return events.filter(event => 
      event.isActive &&
      date >= event.startDate &&
      date <= event.endDate
    );
  }
}
```

## è‡ªç„¶è¨€èªå‡¦ç†ã‚·ã‚¹ãƒ†ãƒ ï¼ˆæ›´æ–°ç‰ˆï¼‰

### ã‚·ãƒ•ãƒˆå¸Œæœ›ã®è§£æ
```javascript
// lib/nlp/shift-parser.js
export class ShiftRequestParser {
  constructor() {
    this.patterns = {
      // æ™‚é–“ãƒ‘ã‚¿ãƒ¼ãƒ³
      timeRange: /(\d{1,2})(?:æ™‚|:)(?:(\d{2})åˆ†?)?[ã€œï½\-](\d{1,2})(?:æ™‚|:)(?:(\d{2})åˆ†?)?/g,
      time24: /(\d{1,2}):(\d{2})/g,
      
      // æ›œæ—¥ãƒ‘ã‚¿ãƒ¼ãƒ³
      weekdays: /(å¹³æ—¥|æœˆç«æ°´æœ¨é‡‘)/,
      weekends: /(åœŸæ—¥|ä¼‘æ—¥|é€±æœ«)/,
      specificDays: /(æœˆ|ç«|æ°´|æœ¨|é‡‘|åœŸ|æ—¥)(?:æ›œæ—¥?)?/g,
      
      // å¸Œæœ›ãƒ»å¤‰æ›´ãƒ‘ã‚¿ãƒ¼ãƒ³
      preferred: /(å¸Œæœ›|ãŠé¡˜ã„|ã§ãã‚Œã°)/,
      unavailable: /(ä¼‘ã¿|NG|ã ã‚|ã§ããªã„|ç„¡ç†)/,
      changeRequest: /(ä»£ã‚|å¤‰æ›´|äº¤ä»£|æ€¥)/,
      
      // æœŸé–“ãƒ‘ã‚¿ãƒ¼ãƒ³
      month: /(æ¥æœˆ|å†æ¥æœˆ|\d+æœˆ)/,
      week: /(æ¥é€±|ä»Šé€±|å†æ¥é€±)/,
      specific: /(\d+)\/(\d+)/
    };
  }
  
  parse(text) {
    // ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›ã‹ã©ã†ã‹ã‚’å…ˆã«åˆ¤å®š
    if (this.isChangeRequest(text)) {
      return this.parseChangeRequest(text);
    }
    
    // é€šå¸¸ã®ã‚·ãƒ•ãƒˆå¸Œæœ›ã¨ã—ã¦è§£æ
    return this.parseShiftRequest(text);
  }
  
  isChangeRequest(text) {
    return this.patterns.changeRequest.test(text) ||
           text.includes('ä»£ã‚ã£ã¦') ||
           text.includes('å¤‰æ›´');
  }
  
  parseChangeRequest(text) {
    const result = {
      type: 'change_request',
      originalText: text,
      targetDate: null,
      reason: null,
      confidence: 0.5
    };
    
    // æ—¥ä»˜ã®æŠ½å‡º
    const dateMatch = text.match(this.patterns.specific);
    if (dateMatch) {
      result.targetDate = `${new Date().getFullYear()}-${dateMatch[1].padStart(2, '0')}-${dateMatch[2].padStart(2, '0')}`;
      result.confidence += 0.3;
    }
    
    // ç†ç”±ã®æŠ½å‡ºï¼ˆç°¡æ˜“ï¼‰
    if (text.includes('ä½“èª¿') || text.includes('é¢¨é‚ª') || text.includes('ç†±')) {
      result.reason = 'ä½“èª¿ä¸è‰¯';
    } else if (text.includes('ç”¨äº‹') || text.includes('äºˆå®š')) {
      result.reason = 'ç§ç”¨';
    } else if (text.includes('æ€¥')) {
      result.reason = 'æ€¥ç”¨';
    }
    
    return result;
  }
  
  parseShiftRequest(text) {
    const result = {
      type: 'shift_request',
      originalText: text,
      timePreferences: {},
      dayPreferences: {},
      notes: [],
      confidence: 0
    };
    
    // æ™‚é–“ç¯„å›²ã®æŠ½å‡º
    const timeMatches = [...text.matchAll(this.patterns.timeRange)];
    if (timeMatches.length > 0) {
      const [, startHour, startMin = '00', endHour, endMin = '00'] = timeMatches[0];
      result.timePreferences.preferredStart = `${startHour.padStart(2, '0')}:${startMin}`;
      result.timePreferences.preferredEnd = `${endHour.padStart(2, '0')}:${endMin}`;
      result.confidence += 0.3;
    }
    
    // æ›œæ—¥ã®æŠ½å‡º
    if (this.patterns.weekdays.test(text)) {
      result.dayPreferences.weekdays = { 
        available: true,
        ...result.timePreferences 
      };
      result.confidence += 0.2;
    }
    
    if (this.patterns.weekends.test(text)) {
      const isUnavailable = this.patterns.unavailable.test(text);
      result.dayPreferences.weekends = { 
        available: !isUnavailable,
        ...(!isUnavailable ? result.timePreferences : {})
      };
      result.confidence += 0.2;
    }
    
    // ç‰¹å®šã®æ›œæ—¥
    const dayMatches = [...text.matchAll(this.patterns.specificDays)];
    if (dayMatches.length > 0) {
      result.dayPreferences.specific = dayMatches.map(match => match[1]);
      result.confidence += 0.1;
    }
    
    // å‚™è€ƒã®æŠ½å‡º
    if (this.patterns.preferred.test(text)) {
      result.notes.push('å¸Œæœ›ã¨ã—ã¦è¨˜éŒ²');
    }
    
    return result;
  }
}
```