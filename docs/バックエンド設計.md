// types/database.ts
export interface DatabaseSchema {
  users: Record<string, User>;
  positions: Position[];
  shifts: Record<string, Shift[]>; // date -> Shift[]
  shiftRequests: Record<string, Record<string, ShiftRequest>>; // month -> userId -> ShiftRequest
  sharedNotices: Notice[];
  dailyMessages: Record<string, DailyMessage[]>; // date -> DailyMessage[]
  substituteRequests: SubstituteRequest[];
  settings: SystemSettings;
  metadata: DatabaseMetadata;
}

export interface User {
  lineUserId: string;
  displayName: string;
  realName?: string;
  role: 'admin' | 'staff';
  isActive: boolean;
  joinedAt: string;
  lastSeenAt: string;
  leftAt?: string;
  preferences?: {
    notifications: boolean;
    timezone: string;
  };
}

export interface Position {
  id: string;
  name: string;
  emoji: string;
  sortOrder: number;
  requiredStaff?: Record<string, number>; // hour -> required count
}

export interface Shift {
  id: string;
  userId: string;
  positionId: string;
  startTime: string; // HH:MM
  endTime: string;   // HH:MM
  breakMinutes: number;
  status: 'draft' | 'preview' | 'confirmed' | 'locked';
  createdAt: string;
  updatedAt?: string;
  createdBy?: string;
  notes?: string;
}

export interface ShiftRequest {
  month: string;
  userId: string;
  requestText: string;
  parsedData: ParsedShiftData;
  submittedAt: string;
  status: 'submitted' | 'processed';
  notes?: string;
}

export interface ParsedShiftData {
  weekdays?: {
    available: boolean;
    preferredStart?: string;
    preferredEnd?: string;
  };
  weekends?: {
    available: boolean;
    preferredStart?: string;
    preferredEnd?: string;
  };
  specificDays?: string[];
  unavailableDates?: string[];
  notes?: string[];
}

export interface Notice {
  id: string;
  title: string;
  content: string;
  category: 'equipment' | 'staff' | 'operation' | 'other';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  startDate: string;
  endDate?: string;
  isActive: boolean;
  createdBy: string;
  createdAt: string;
  updatedAt?: string;
}

export interface DailyMessage {
  id: string;
  userName: string;
  message: string;
  messageType: 'chat' | 'line_import' | 'admin_memo' | 'system';
  isPrivate: boolean;
  createdAt: string;
  userId?: string;
}

export interface SubstituteRequest {
  id: string;
  shiftId?: string;
  requesterId: string;
  substituteId?: string;
  targetDate: string;
  reason: string;
  status: 'pending' | 'accepted' | 'rejected' | 'cancelled';
  requestedAt: string;
  respondedAt?: string;
  notes?: string;
}

export interface SystemSettings {
  storeName: string;
  businessHours: string;
  adminLineUserId: string;
  shiftDeadlineDay: number;
  autoBreakEnabled: boolean;
  breakRules: Record<string, number>;
  timezone: string;
  specialEvents?: SpecialEvent[];
  dynamicHolidays?: Record<string, Record<string, any>>;
}

export interface SpecialEvent {
  id: string;
  name: string;
  startDate: string;
  endDate: string;
  additionalStaff: Record<string, number>; // positionId -> additional count
  description?: string;
  isActive: boolean;
  createdAt: string;
}

export interface DatabaseMetadata {
  version: string;
  createdAt: string;
  lastUpdatedAt: string;
  totalUsers: number;
  totalShifts: number;
  lastBackupAt?: string;
}
```

---

## LINE Bot処理

### 1. メンション処理エンジン

```typescript
// lib/line-mention-handler.ts
import { Client } from '@line/bot-sdk';
import { MentionParser } from './nlp/mention-parser';
import { ShiftStateManager } from './shift-state-manager';
import { NotificationManager } from './notification-manager';
import { db } from './database';

export class LineMentionHandler {
  private client: Client;
  private mentionParser: MentionParser;
  private stateManager: ShiftStateManager;
  private notificationManager: NotificationManager;

  constructor(lineClient: Client) {
    this.client = lineClient;
    this.mentionParser = new MentionParser();
    this.stateManager = new ShiftStateManager(db);
    this.notificationManager = new NotificationManager(lineClient, db);
  }

  async handleMessage(event: any): Promise<void> {
    const messageText = event.message.text;
    const lineUserId = event.source.userId;
    const replyToken = event.replyToken;

    try {
      // ユーザー情報取得・更新
      const user = await this.getOrCreateUser(lineUserId);
      
      // アクティビティ更新
      await db.saveUser(lineUserId, { 
        lastSeenAt: new Date().toISOString() 
      });

      // メンション解析
      const parsed = this.mentionParser.parse(messageText, user);

      if (!parsed) {
        // メンションなしの場合は日常会話として処理
        return await this.handleChatMessage(messageText, user, event);
      }

      // レート制限チェック
      if (!await this.checkRateLimit(lineUserId)) {
        return await this.replyMessage(replyToken, 
          '申し訳ございません。しばらく時間をおいてから再度お試しください。');
      }

      // 意図別処理
      await this.handleIntent(parsed, event);

    } catch (error) {
      console.error('Message handling error:', error);
      await this.replyMessage(replyToken, 
        '申し訳ございません。エラーが発生しました。\n管理者にお問い合わせください。');
    }
  }

  private async getOrCreateUser(lineUserId: string): Promise<User> {
    let user = await db.getUser(lineUserId);
    
    if (!user) {
      // 新規ユーザーの場合はプロフィール取得して登録
      try {
        const profile = await this.client.getProfile(lineUserId);
        user = await db.saveUser(lineUserId, {
          displayName: profile.displayName,
          role: 'staff',
          isActive: true
        });
        
        // ウェルカムメッセージ送信
        await this.sendWelcomeMessage(lineUserId, profile.displayName);
      } catch (error) {
        console.error('Failed to get user profile:', error);
        // プロフィール取得失敗時は最低限のユーザー情報で登録
        user = await db.saveUser(lineUserId, {
          displayName: 'Unknown User',
          role: 'staff',
          isActive: true
        });
      }
    }
    
    return user;
  }

  private async handleIntent(parsed: any, event: any): Promise<void> {
    const { intent, parameters, user } = parsed;

    switch (intent) {
      case 'shiftQuery':
        await this.handleShiftQuery(parameters, user, event);
        break;
      case 'shiftRequest':
        await this.handleShiftRequest(parameters, user, event);
        break;
      case 'changeRequest':
        await this.handleChangeRequest(parameters, user, event);
        break;
      case 'pdfRequest':
        await this.handlePdfRequest(parameters, user, event);
        break;
      case 'noticeQuery':
        await this.handleNoticeQuery(parameters, user, event);
        break;
      case 'helpRequest':
        await this.handleHelpRequest(user, event);
        break;
      
      // 管理者専用機能
      case 'adminPreview':
        await this.handleAdminPreview(parameters, user, event);
        break;
      case 'adminConfirm':
        await this.handleAdminConfirm(parameters, user, event);
        break;
      case 'adminAssign':
        await this.handleAdminAssign(parameters, user, event);
        break;
      case 'eventManagement':
        await this.handleEventManagement(parameters, user, event);
        break;
        
      default:
        await this.handleUnknownIntent(parsed, event);
    }
  }

  // === 意図別ハンドラー ===

  private async handleShiftRequest(params: any, user: User, event: any): Promise<void> {
    if (user.role !== 'admin' && user.role !== 'staff') {
      return await this.replyMessage(event.replyToken, 
        '⚠️ シフト提出権限がありません。管理者にお問い合わせください。');
    }

    try {
      // シフト希望データの構造化
      const shiftRequestData = {
        month: params.month || this.getNextMonth(),
        userId: user.lineUserId,
        requestText: event.message.text,
        parsedData: {
          weekdays: params.weekdays,
          weekends: params.weekends,
          timeRange: params.timeRange,
          specificDays: params.specificDays,
          notes: params.notes || []
        },
        submittedAt: new Date().toISOString(),
        status: 'submitted' as const
      };

      // シフト希望を保存
      await this.saveShiftRequest(shiftRequestData);

      // 仮シフト自動生成
      await this.stateManager.generatePreviewShift(shiftRequestData.month);

      // 確認メッセージ
      const response = this.formatShiftRequestResponse(shiftRequestData);
      await this.replyMessage(event.replyToken, response);

      // 管理者に通知
      await this.notificationManager.notifyShiftRequestSubmitted(user, shiftRequestData);

    } catch (error) {
      console.error('Shift request handling error:', error);
      await this.replyMessage(event.replyToken, 
        'シフト希望の処理中にエラーが発生しました。もう一度お試しください。');
    }
  }

  private async handleAdminPreview(params: any, user: User, event: any): Promise<void> {
    if (user.role !== 'admin') {
      return await this.replyMessage(event.replyToken, 
        '⚠️ 管理者権限が必要です。');
    }

    try {
      const targetMonth = params.month || this.getNextMonth();
      
      // 仮シフト状況分析
      const analysis = await this.stateManager.analyzeShiftCoverage(targetMonth);
      
      // 分析結果をフォーマット
      const response = this.formatShiftAnalysisResponse(targetMonth, analysis);
      
      await this.replyMessage(event.replyToken, response);
      
    } catch (error) {
      console.error('Admin preview error:', error);
      await this.replyMessage(event.replyToken, 
        '仮シフト分析中にエラーが発生しました。');
    }
  }

  private async handleAdminConfirm(params: any, user: User, event: any): Promise<void> {
    if (user.role !== 'admin') {
      return await this.replyMessage(event.replyToken, 
        '⚠️ 管理者権限が必要です。');
    }

    try {
      const targetMonth = params.month || this.getNextMonth();
      
      // 重大な人手不足チェック
      const criticalShortages = await this.stateManager.checkCriticalShortages(targetMonth);
      
      if (criticalShortages.length > 0 && !params.forceConfirm) {
        const warningMessage = this.formatShortageWarning(criticalShortages);
        return await this.replyMessage(event.replyToken, warningMessage);
      }

      // シフト確定処理
      await this.stateManager.confirmShifts(targetMonth, user.lineUserId);
      
      // 全スタッフに通知
      await this.notificationManager.notifyShiftConfirmed(targetMonth);
      
      const response = `🔒 **${targetMonth} シフト確定完了**\n\n` +
                      `すべてのスタッフに確定通知を送信しました。`;
      
      await this.replyMessage(event.replyToken, response);
      
    } catch (error) {
      console.error('Shift confirmation error:', error);
      await this.replyMessage(event.replyToken, 
        'シフト確定処理中にエラーが発生しました。');
    }
  }

  // === ユーティリティメソッド ===

  private async saveShiftRequest(requestData: any): Promise<void> {
    if (!db.data.shiftRequests[requestData.month]) {
      db.data.shiftRequests[requestData.month] = {};
    }
    
    db.data.shiftRequests[requestData.month][requestData.userId] = requestData;
    await db.save();
  }

  private formatShiftRequestResponse(requestData: any): string {
    return `✅ シフト希望を受け付けました！

📅 **対象月**: ${requestData.month}
⏰ **希望時間**: ${this.formatTimePreferences(requestData.parsedData)}
📋 **曜日設定**: ${this.formatDayPreferences(requestData.parsedData)}

🔄 仮シフトに自動反映しました。
責任者による確定をお待ちください。

📱 シフト確認: @シフトボット 来月のシフト`;
  }

  private formatTimePreferences(parsedData: any): string {
    if (parsedData.timeRange) {
      return `${parsedData.timeRange.start} - ${parsedData.timeRange.end}`;
    }
    return '未指定';
  }

  private formatDayPreferences(parsedData: any): string {
    const parts = [];
    if (parsedData.weekdays?.available) parts.push('平日OK');
    if (parsedData.weekends?.available === false) parts.push('土日休み');
    if (parsedData.weekends?.available === true) parts.push('土日OK');
    return parts.length > 0 ? parts.join(', ') : '未指定';
  }

  private async replyMessage(replyToken: string, text: string): Promise<void> {
    try {
      await this.client.replyMessage(replyToken, {
        type: 'text',
        text: text
      });
    } catch (error) {
      console.error('Reply message error:', error);
    }
  }

  private async checkRateLimit(userId: string): Promise<boolean> {
    // 簡易レート制限（メモリベース）
    // 本格運用時はRedisなどを使用
    return true; // 暫定的に常にtrue
  }

  private getNextMonth(): string {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    return nextMonth.toISOString().slice(0, 7);
  }
}
```

### 2. 自然言語処理（簡易版）

```typescript
// lib/nlp/mention-parser.ts
export class MentionParser {
  private botMentions = ['@シフトボット', '@シフト', '@shift', '@bot'];
  
  private intentPatterns = {
    // シフト確認系
    shiftQuery: [
      /(今月|当月|今日|明日|来週|来月)の?シフト/,
      /シフト.*?(確認|教えて|見せて|表示)/,
      /(明日|今日).*?(勤務|シフト)/,
      /(\d+)月(\d+)日.*?シフト/
    ],
    
    // シフト希望提出
    shiftRequest: [
      /(来月|再来月|\d+月).*?希望/,
      /シフト.*?希望/,
      /(平日|土日|週末).*?(時間|勤務)/,
      /(\d{1,2})時.*?(\d{1,2})時/
    ],
    
    // シフト変更希望
    changeRequest: [
      /(代わって|交代|変更).*?(もらえ|して|お願い)/,
      /(休み|お休み).*?(もらえ|したい|お願い)/,
      /(急用|用事|体調).*?(代わり|交代)/
    ],
    
    // PDF・画像要求
    pdfRequest: [
      /(PDF|pdf).*?(欲しい|下さい|ください)/,
      /(画像|写真).*?(欲しい|下さい|保存)/,
      /シフト表.*?(保存|ダウンロード)/
    ],
    
    // ヘルプ
    helpRequest: [
      /(使い方|操作|方法).*?(教えて|分からない)/,
      /(何|どう).*?(できる|する)/,
      /(ヘルプ|help)/
    ],
    
    // 管理者機能
    adminPreview: [
      /(仮|プレビュー).*?シフト.*?(見せて|確認|表示)/,
      /(来月|今月).*?(状況|様子).*?(確認|教えて)/
    ],
    
    adminConfirm: [
      /(シフト|来月).*?(確定|決定).*?(して|お願い)/,
      /(確定|決定).*?シフト/
    ]
  };

  parse(text: string, user: any): any {
    // @メンションの確認
    const mention = this.extractMention(text);
    if (!mention) return null;

    // メンション部分を除去
    const cleanText = this.removeMention(text);

    // 意図を分析
    const intent = this.analyzeIntent(cleanText);

    // パラメータを抽出
    const parameters = this.extractParameters(cleanText, intent);

    return {
      type: 'mention',
      mention,
      originalText: text,
      cleanText,
      intent,
      parameters,
      confidence: this.calculateConfidence(cleanText, intent),
      user
    };
  }

  private extractMention(text: string): string | null {
    for (const mention of this.botMentions) {
      if (text.includes(mention)) {
        return mention;
      }
    }
    return null;
  }

  private removeMention(text: string): string {
    let cleanText = text;
    for (const mention of this.botMentions) {
      cleanText = cleanText.replace(mention, '').trim();
    }
    return cleanText;
  }

  private analyzeIntent(text: string): string {
    for (const [intent, patterns] of Object.entries(this.intentPatterns)) {
      for (const pattern of patterns) {
        if (pattern.test(text)) {
          return intent;
        }
      }
    }
    return 'general';
  }

  private extractParameters(text: string, intent: string): any {
    const params: any = {};

    switch (intent) {
      case 'shiftRequest':
        params.timeRange = this.extractTimeRange(text);
        params.weekdays = this.extractWeekdayPreference(text);
        params.weekends = this.extractWeekendPreference(text);
        params.month = this.extractMonth(text);
        break;
        
      case 'shiftQuery':
        params.period = this.extractTimePeriod(text);
        params.date = this.extractSpecificDate(text);
        break;
        
      case 'changeRequest':
        params.targetDate = this.extractSpecificDate(text);
        params.reason = this.extractReason(text);
        break;
    }

    return params;
  }

  private extractTimeRange(text: string): any {
    const timePattern = /(\d{1,2})時.*?(\d{1,2})時/;
    const match = text.match(timePattern);
    
    if (match) {
      return {
        start: `${match[1].padStart(2, '0')}:00`,
        end: `${match[2].padStart(2, '0')}:00`
      };
    }
    return null;
  }

  private extractWeekdayPreference(text: string): any {
    if (text.includes('平日')) {
      return { available: true };
    }
    return null;
  }

  private extractWeekendPreference(text: string): any {
    if (text.includes('土日')) {
      const isUnavailable = text.includes('休み') || text.includes('NG');
      return { available: !isUnavailable };
    }
    return null;
  }

  private extractMonth(text: string): string | null {
    if (text.includes('来月')) {
      const now = new Date();
      const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      return nextMonth.toISOString().slice(0, 7);
    }
    return null;
  }

  private extractTimePeriod(text: string): string | null {
    if (text.includes('今月') || text.includes('当月')) return 'current_month';
    if (text.includes('来月')) return 'next_month';
    if (text.includes('今日')) return 'today';
    if (text.includes('明日')) return 'tomorrow';
    return null;
  }

  private extractSpecificDate(text: string): string | null {
    const datePattern = /(\d+)月(\d+)日/;
    const match = text.match(datePattern);
    
    if (match) {
      const month = match[1].padStart(2, '0');
      const day = match[2].padStart(2, '0');
      return `${new Date().getFullYear()}-${month}-${day}`;
    }
    return null;
  }

  private extractReason(text: string): string {
    if (text.includes('体調') || text.includes('風邪')) return '体調不良';
    if (text.includes('用事') || text.includes('予定')) return '私用';
    if (text.includes('急')) return '急用';
    return '未指定';
  }

  private calculateConfidence(text: string, intent: string): number {
    const patterns = this.intentPatterns[intent] || [];
    let confidence = 0;
    
    for (const pattern of patterns) {
      if (pattern.test(text)) {
        confidence = Math.max(confidence, 0.8);
      }
    }
    
    return confidence;
  }
}
```

---

## バックグラウンド処理

### 1. 定期実行ジョブ

```typescript
// lib/scheduled-jobs.ts
import cron from 'node-cron';
import { db } from './database';
import { NotificationManager } from './notification-manager';

export class ScheduledJobManager {
  private notificationManager: NotificationManager;

  constructor(lineClient: any) {
    this.notificationManager = new NotificationManager(lineClient, db);
    this.initializeJobs();
  }

  private initializeJobs(): void {
    // 毎日20:00に翌日のシフト通知
    cron.schedule('0 20 * * *', async () => {
      await this.sendDailyShiftNotification();
    }, {
      timezone: 'Asia/Tokyo'
    });

    // 毎月25日20:00にシフト提出催促
    cron.schedule('0 20 25 * *', async () => {
      await this.sendShiftSubmissionReminder();
    }, {
      timezone: 'Asia/Tokyo'
    });

    // 毎日2:00にデータバックアップ
    cron.schedule('0 2 * * *', async () => {
      await this.performDailyBackup();
    }, {
      timezone: 'Asia/Tokyo'
    });

    // 毎月1日3:00にデータアーカイブ
    cron.schedule('0 3 1 * *', async () => {
      await this.performMonthlyArchive();
    }, {
      timezone: 'Asia/Tokyo'
    });

    console.log('Scheduled jobs initialized');
  }

  private async sendDailyShiftNotification(): Promise<void> {
    try {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowStr = tomorrow.toISOString().split('T')[0];

      const shifts = await db.getShifts(tomorrowStr);
      const activeUsers = await db.getActiveUsers();
      const positions = await db.getPositions();

      // 明日シフトがあるユーザーに通知
      const notifications = [];
      
      for (const user of activeUsers) {
        const userShifts = shifts.filter(s => s.userId === user.lineUserId);
        
        if (userShifts.length > 0) {
          const message = this.formatTomorrowShiftMessage(userShifts, positions, tomorrowStr);
          notifications.push(
            this.notificationManager.sendPersonalNotification(user.lineUserId, message)
          );
        }
      }

      await Promise.all(notifications);
      console.log(`Daily shift notifications sent to ${notifications.length} users`);
      
    } catch (error) {
      console.error('Daily shift notification error:', error);
    }
  }

  private async sendShiftSubmissionReminder(): Promise<void> {
    try {
      const nextMonth = this.getNextMonth();
      const activeUsers = await db.getActiveUsers();
      const submittedUsers = await this.getSubmittedUsers(nextMonth);

      // 未提出ユーザーに催促
      const reminderPromises = [];
      
      for (const user of activeUsers) {
        if (user.role === 'staff' && !submittedUsers.has(user.lineUserId)) {
          const message = this.formatSubmissionReminderMessage(nextMonth);
          reminderPromises.push(
            this.notificationManager.sendPersonalNotification(user.lineUserId, message)
          );
        }
      }

      await Promise.all(reminderPromises);
      console.log(`Submission reminders sent to ${reminderPromises.length} users`);
      
    } catch (error) {
      console.error('Submission reminder error:', error);
    }
  }

  private async performDailyBackup(): Promise<void> {
    try {
      // データベースの状態を強制保存（バックアップトリガー）
      await db.save();
      
      // バックアップ成功をログ
      console.log('Daily backup completed');
      
    } catch (error) {
      console.error('Daily backup error:', error);
    }
  }

  private async performMonthlyArchive(): Promise<void> {
    try {
      // 6ヶ月以上前のデータをアーカイブ
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
      const cutoffDate = sixMonthsAgo.toISOString().split('T')[0];

      await this.archiveOldData(cutoffDate);
      console.log('Monthly archive completed');
      
    } catch (error) {
      console.error('Monthly archive error:', error);
    }
  }

  private formatTomorrowShiftMessage(shifts: any[], positions: any[], date: string): string {
    const dayOfWeek = this.getDayOfWeek(date);
    let message = `🌅 **明日のシフトのお知らせ**\n\n`;
    message += `📅 ${date} (${dayOfWeek})\n\n`;

    for (const shift of shifts) {
      const position = positions.find(p => p.id === shift.positionId);
      message += `${position?.emoji || '📍'} **${position?.name || 'Unknown'}**\n`;
      message += `⏰ ${shift.startTime} - ${shift.endTime}\n`;
      if (shift.breakMinutes > 0) {
        message += `☕ 休憩: ${shift.breakMinutes}分\n`;
      }
      message += `\n`;
    }

    message += `💪 お疲れさまです！明日もよろしくお願いします。\n\n`;
    message += `❓ 何か変更がある場合は、@シフトボット にご連絡ください。`;

    return message;
  }

  private formatSubmissionReminderMessage(month: string): string {
    return `📝 **シフト希望提出のお知らせ**

${month}のシフト希望がまだ提出されていません。

🗓️ **提出期限**: 今日まで
📱 **提出方法**: @シフトボット 来月希望です

例：
@シフトボット 来月希望です。平日9時から17時、土日休み

お忙しいとは思いますが、シフト作成のため早めの提出をお願いいたします。`;
  }

  private async getSubmittedUsers(month: string): Promise<Set<string>> {
    await db.load();
    const requests = db.data.shiftRequests[month] || {};
    return new Set(Object.keys(requests));
  }

  private getNextMonth(): string {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    return nextMonth.toISOString().slice(0, 7);
  }

  private getDayOfWeek(date: string): string {
    const days = ['日', '月', '火', '水', '木', '金', '土'];
    return days[new Date(date).getDay()];
  }

  private async archiveOldData(cutoffDate: string): Promise<void> {
    await db.load();
    
    const archiveData = {
      shifts: {},
      dailyMessages: {},
      archivedAt: new Date().toISOString()
    };

    // 古いシフトデータをアーカイブ
    for (const [date, shifts] of Object.entries(db.data.shifts)) {
      if (date < cutoffDate) {
        archiveData.shifts[date] = shifts;
        delete db.data.shifts[date];
      }
    }

    // 古いメッセージデータをアーカイブ
    for (const [date, messages] of Object.entries(db.data.dailyMessages)) {
      if (date < cutoffDate) {
        archiveData.dailyMessages[date] = messages;
        delete db.data.dailyMessages[date];
      }
    }

    // アーカイブファイル保存
    if (Object.keys(archiveData.shifts).length > 0 || Object.keys(archiveData.dailyMessages).length > 0) {
      const archivePath = path.join(process.cwd(), `data/archives/archive_${cutoffDate}.json`);
      await fs.mkdir(path.dirname(archivePath), { recursive: true });
      await fs.writeFile(archivePath, JSON.stringify(archiveData, null, 2));
      
      // メインデータベース保存
      await db.save();
      
      console.log(`Archived data before ${cutoffDate}`);
    }
  }
}
```

### 2. 通知管理システム

```typescript
// lib/notification-manager.ts
import { Client } from '@line/bot-sdk';
import { JSONDatabase } from './database';

export class NotificationManager {
  private client: Client;
  private db: JSONDatabase;

  constructor(lineClient: Client, database: JSONDatabase) {
    this.client = lineClient;
    this.db = database;
  }

  // 個人通知
  async sendPersonalNotification(userId: string, message: string): Promise<void> {
    try {
      await this.client.pushMessage(userId, {
        type: 'text',
        text: message
      });
    } catch (error) {
      console.error(`Failed to send notification to ${userId}:`, error);
    }
  }

  // 管理者通知
  async notifyAdmins(message: string): Promise<void> {
    const activeUsers = await this.db.getActiveUsers();
    const admins = activeUsers.filter(user => user.role === 'admin');

    const notifications = admins.map(admin => 
      this.sendPersonalNotification(admin.lineUserId, message)
    );

    await Promise.all(notifications);
  }

  // 全スタッフ通知
  async notifyAllStaff(message: string): Promise<void> {
    const activeUsers = await this.db.getActiveUsers();

    const notifications = activeUsers.map(user => 
      this.sendPersonalNotification(user.lineUserId, message)
    );

    await Promise.all(notifications);
  }

  // シフト希望提出通知
  async notifyShiftRequestSubmitted(user: any, requestData: any): Promise<void> {
    const message = `📝 **新しいシフト希望**

👤 **提出者**: ${user.displayName}さん
📅 **対象月**: ${requestData.month}
📝 **内容**: ${requestData.requestText}

仮シフトに自動反映されました。
確認は「@シフトボット 来月の仮シフト見せて」で行えます。`;

    await this.notifyAdmins(message);
  }

  // シフト確定通知
  async notifyShiftConfirmed(month: string): Promise<void> {
    const message = `🔒 **${month} シフト確定のお知らせ**

お疲れさまです！
${month}のシフトが確定しました。

📱 **確認方法**:
@シフトボット 来月のシフト

📄 **PDF保存**:
@シフトボット シフト表のPDF欲しい

変更が必要な場合は、お早めに管理者までご連絡ください。`;

    await this.notifyAllStaff(message);
  }

  // 人手不足警告通知
  async notifyStaffShortage(shortageData: any): Promise<void> {
    const message = `⚠️ **人手不足警告**

以下の日時で人手が不足しています：

${shortageData.map(item => 
  `📅 ${item.date} ${item.position}: ${item.shortage}名不足`
).join('\n')}

可能であれば追加でシフトに入っていただける方を募集しています。
ご協力いただける方は管理者までご連絡ください。`;

    await this.notifyAllStaff(message);
  }

  // 代替依頼通知
  async notifySubstituteRequest(requestData: any): Promise<void> {
    const message = `🔄 **シフト代替依頼**

📅 **対象日**: ${requestData.targetDate}
👤 **依頼者**: ${requestData.requesterName}
💭 **理由**: ${requestData.reason}
📝 **詳細**: ${requestData.originalText}

代替可能な方は管理者までご連絡ください。`;

    await this.notifyAllStaff(message);
  }

  // システムメンテナンス通知
  async notifyMaintenance(maintenanceInfo: any): Promise<void> {
    const message = `🔧 **システムメンテナンスのお知らせ**

📅 **実施日時**: ${maintenanceInfo.startTime} 〜 ${maintenanceInfo.endTime}
📝 **内容**: ${maintenanceInfo.description}

メンテナンス中はシフトボットが利用できません。
緊急時は直接管理者までご連絡ください。`;

    await this.notifyAllStaff(message);
  }

  // エラー通知（管理者のみ）
  async notifySystemError(error: any): Promise<void> {
    const message = `🚨 **システムエラー発生**

⏰ **発生時刻**: ${new Date().toLocaleString('ja-JP')}
🔍 **エラー内容**: ${error.message}
📍 **発生場所**: ${error.location || 'Unknown'}

システム管理者による対応が必要です。`;

    await this.notifyAdmins(message);
  }

  // リッチメッセージ送信（ボタン付き）
  async sendRichMessage(userId: string, text: string, actions: any[]): Promise<void> {
    try {
      const message = {
        type: 'template',
        altText: text,
        template: {
          type: 'buttons',
          text: text,
          actions: actions
        }
      };

      await this.client.pushMessage(userId, message);
    } catch (error) {
      console.error(`Failed to send rich message to ${userId}:`, error);
      // フォールバック：通常のテキストメッセージ
      await this.sendPersonalNotification(userId, text);
    }
  }

  // Flex Message送信（カード形式）
  async sendFlexMessage(userId: string, flexData: any): Promise<void> {
    try {
      const message = {
        type: 'flex',
        altText: flexData.altText || 'シフト情報',
        contents: flexData
      };

      await this.client.pushMessage(userId, message);
    } catch (error) {
      console.error(`Failed to send flex message to ${userId}:`, error);
    }
  }
}
```

---

## セキュリティ設計

### 1. 認証・認可システム

```typescript
// lib/security.ts
import crypto from 'crypto';
import { NextApiRequest } from 'next';

// LINE署名検証
export function validateLineSignature(
  body: string,
  signature: string,
  channelSecret: string
): boolean {
  const hash = crypto
    .createHmac('SHA256', channelSecret)
    .update(body, 'utf8')
    .digest('base64');
  
  return hash === signature;
}

// APIキー検証（内部API用）
export function validateApiKey(req: NextApiRequest): boolean {
  const apiKey = req.headers['x-api-key'];
  const validApiKey = process.env.INTERNAL_API_KEY;
  
  if (!apiKey || !validApiKey) {
    return false;
  }
  
  return crypto.timingSafeEqual(
    Buffer.from(apiKey as string),
    Buffer.from(validApiKey)
  );
}

// レート制限
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

export function checkRateLimit(
  identifier: string,
  maxRequests: number = 100,
  windowMs: number = 60000
): boolean {
  const now = Date.now();
  const limit = rateLimitStore.get(identifier);
  
  if (!limit || now > limit.resetTime) {
    rateLimitStore.set(identifier, {
      count: 1,
      resetTime: now + windowMs
    });
    return true;
  }
  
  if (limit.count >= maxRequests) {
    return false;
  }
  
  limit.count++;
  return true;
}

// 入力値サニタイゼーション
export function sanitizeInput(input: string): string {
  return input
    .replace(/[<>]/g, '')  // HTMLタグ防止
    .replace(/['"]/g, '')  // クォート防止
    .trim()
    .slice(0, 1000);       // 長さ制限
}

// ユーザー権限チェック
export async function checkUserPermission(
  lineUserId: string,
  requiredRole: 'admin' | 'staff'
): Promise<boolean> {
  try {
    const { db } = await import('./database');
    const user = await db.getUser(lineUserId);
    
    if (!user || !user.isActive) {
      return false;
    }
    
    if (requiredRole === 'admin') {
      return user.role === 'admin';
    }
    
    return user.role === 'admin' || user.role === 'staff';
  } catch (error) {
    console.error('Permission check error:', error);
    return false;
  }
}

// セキュアなファイルパス生成
export function sanitizeFilePath(filename: string): string {
  return filename
    .replace(/[^a-zA-Z0-9._-]/g, '')  // 安全な文字のみ
    .replace(/\.{2,}/g, '.')          // 連続ドット防止
    .slice(0, 100);                   // 長さ制限
}

// CSRFトークン生成（将来の拡張用）
export function generateCSRFToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

// 秘密情報のマスキング
export function maskSensitiveData(data: any): any {
  const masked = { ...data };
  
  const sensitiveFields = ['lineUserId', 'accessToken', 'channelSecret'];
  
  for (const field of sensitiveFields) {
    if (masked[field]) {
      const value = masked[field];
      masked[field] = value.slice(0, 4) + '*'.repeat(value.length - 8) + value.slice(-4);
    }
  }
  
  return masked;
}
```

### 2. エラーハンドリング

```typescript
// lib/error-handler.ts
export class AppError extends Error {
  public statusCode: number;
  public code: string;
  public isOperational: boolean;

  constructor(
    message: string,
    statusCode: number = 500,
    code: string = 'INTERNAL_ERROR',
    isOperational: boolean = true
  ) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;
    this.name = this.constructor.name;

    Error.captureStackTrace(this, this.constructor);
  }
}

// 定義済みエラー
export class ValidationError extends AppError {
  constructor(message: string, field?: string) {
    super(`Validation failed: ${message}`, 400, 'VALIDATION_ERROR');
    this.field = field;
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 404, 'NOT_FOUND');
  }
}

export class PermissionError extends AppError {
  constructor(action: string) {
    super(`Permission denied for: ${action}`, 403, 'PERMISSION_DENIED');
  }
}

export class RateLimitError extends AppError {
  constructor() {
    super('Rate limit exceeded', 429, 'RATE_LIMIT_EXCEEDED');
  }
}

// エラーハンドラー
export function handleError(error: any, req?: any, res?: any): void {
  console.error('Error details:', {
    message: error.message,
    stack: error.stack,
    code: error.code,
    statusCode: error.statusCode,
    url: req?.url,
    method: req?.method,
    userId: req?.user?.lineUserId,
    timestamp: new Date().toISOString()
  });

  // 本番環境では詳細なエラー情報を隠す
  if (process.env.NODE_ENV === 'production' && res) {
    const isOperational = error.isOperational || false;
    
    if (!isOperational) {
      // システムエラーは汎用メッセージ
      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred'
        }
      });
    } else {
      // 運用エラーは詳細を返す
      res.status(error.statusCode || 500).json({
        success: false,
        error: {
          code: error.code,
          message: error.message
        }
      });
    }
  }
}

// 非同期エラーハンドラー
export function asyncHandler(fn: Function) {
  return (req: any, res: any, next: any) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// グローバルエラーハンドラー設定
export function setupGlobalErrorHandlers(): void {
  process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    process.exit(1);
  });

  process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
  });
}
```

---

## デプロイ・運用

### 1. Vercel設定

```json
// vercel.json
{
  "functions": {
    "pages/api/webhook.js": {
      "maxDuration": 10
    },
    "pages/api/pdf/[date].js": {
      "maxDuration": 30
    },
    "pages/api/shift/month/[month].js": {
      "maxDuration": 15
    }
  },
  "crons": [
    {
      "path": "/api/cron/daily-notification",
      "schedule": "0 20 * * *"
    },
    {
      "path": "/api/cron/submission-reminder", 
      "schedule": "0 20 25 * *"
    },
    {
      "path": "/api/cron/daily-backup",
      "schedule": "0 2 * * *"
    }
  ],
  "build": {
    "env": {
      "PUPPETEER_SKIP_CHROMIUM_DOWNLOAD": "true"
    }
  },
  "regions": ["nrt1"],
  "framework": "nextjs"
}
```

### 2. 環境変数設定

```bash
# .env.local (開発環境)
LINE_CHANNEL_SECRET=your_line_channel_secret
LINE_CHANNEL_ACCESS_TOKEN=your_line_access_token
INTERNAL_API_KEY=your_internal_api_key_for_cron_jobs
PUPPETEER_EXECUTABLE_PATH=/usr/bin/google-chrome-stable

# .env.production (本番環境)
NODE_ENV=production
LINE_CHANNEL_SECRET=prod_line_channel_secret
LINE_CHANNEL_ACCESS_TOKEN=prod_line_access_token
INTERNAL_API_KEY=prod_internal_api_key
NEXT_PUBLIC_BASE_URL=https://your-app.vercel.app
```

### 3. パッケージ.json

```json
{
  "name": "line-bot-shift-backend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "backup": "node scripts/backup.js",
    "restore": "node scripts/restore.js"
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "@line/bot-sdk": "^7.5.2",
    "puppeteer": "^21.5.0",
    "node-cron": "^3.0.2",
    "qrcode": "^1.5.3"
  },
  "devDependencies": {
    "@types/node": "^20.8.0",
    "@types/react": "^18.2.0",
    "@types/node-cron": "^3.0.8",
    "@types/qrcode": "^1.5.0",
    "typescript": "^5.2.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.5",
    "eslint": "^8.51.0",
    "eslint-config-next": "^14.0.0"
  }
}
```

### 4. 運用スクリプト

```typescript
// scripts/backup.ts
import { db } from '../lib/database';
import path from 'path';
import fs from 'fs/promises';

async function performBackup() {
  try {
    console.log('Starting manual backup...');
    
    // データベース読み込み
    await db.load();
    
    // バックアップファイル作成
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(process.cwd(), `backups/manual_backup_${timestamp}.json`);
    
    await fs.mkdir(path.dirname(backupPath), { recursive: true });
    await fs.writeFile(backupPath, JSON.stringify(db.data, null, 2));
    
    console.log(`Backup completed: ${backupPath}`);
    
    // 統計情報表示
    const stats = {
      users: Object.keys(db.data.users).length,
      shifts: Object.values(db.data.shifts).flat().length,
      notices: db.data.sharedNotices.filter(n => n.isActive).length
    };
    
    console.log('Backup statistics:', stats);
    
  } catch (error) {
    console.error('Backup failed:', error);
    process.exit(1);
  }
}

// スクリプト実行
if (require.main === module) {
  performBackup();
}
```

### 5. ヘルスチェックAPI

```typescript
// pages/api/health.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { db } from '../../lib/database';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // データベース接続確認
    await db.load();
    
    // 基本統計取得
    const stats = await db.getStatistics();
    
    // システム情報
    const systemInfo = {
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      version: process.env.npm_package_version || '1.0.0',
      nodeVersion: process.version
    };

    // ヘルスチェック結果
    const healthCheck = {
      status: 'healthy',
      database: 'connected',
      statistics: stats,
      system: systemInfo
    };

    res.status(200).json(healthCheck);
    
  } catch (error) {
    console.error('Health check failed:', error);
    
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
}
```

### 6. 監視・アラート設定

```typescript
// lib/monitoring.ts
export class MonitoringManager {
  // メトリクス収集
  static collectMetrics() {
    return {
      memory: process.memoryUsage(),
      uptime: process.uptime(),
      timestamp: Date.now()
    };
  }

  // パフォーマンス監視
  static async measureApiPerformance(apiName: string, operation: () => Promise<any>) {
    const start = Date.now();
    
    try {
      const result = await operation();
      const duration = Date.now() - start;
      
      // 遅いAPIの警告
      if (duration > 3000) {
        console.warn(`Slow API detected: ${apiName} took ${duration}ms`);
      }
      
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      console.error(`API failed: ${apiName} after ${duration}ms`, error);
      throw error;
    }
  }

  // データベース整合性チェック
  static async checkDataIntegrity(): Promise<{ isHealthy: boolean; issues: string[] }> {
    const issues: string[] = [];
    
    try {
      await db.load();
      
      // ユーザーデータ整合性
      for (const [userId, user] of Object.entries(db.data.users)) {
        if (!user.lineUserId) {
          issues.push(`User ${userId} missing lineUserId`);
        }
        if (!user.joinedAt) {
          issues.push(`User ${userId} missing joinedAt`);
        }
      }
      
      // シフトデータ整合性
      for (const [date, shifts] of Object.entries(db.data.shifts)) {
        for (const shift of shifts) {
          if (!shift.userId || !shift.positionId) {
            issues.push(`Shift ${shift.id} missing required fields`);
          }
        }
      }
      
      return {
        isHealthy: issues.length === 0,
        issues
      };
      
    } catch (error) {
      issues.push(`Database integrity check failed: ${error.message}`);
      return { isHealthy: false, issues };
    }
  }
}
```

---

## 総合アーキテクチャまとめ

### システム特徴

1. **軽量・保守性重視**
   - JSONベースのデータストレージ
   - サーバーレス対応設計
   - 最小限の依存関係

2. **LINE中心の運用**
   - Webhook駆動のアーキテクチャ
   - 自然言語処理（簡易版）
   - リアルタイム通知システム

3. **スケーラビリティ**
   - ファイルベース→PostgreSQL移行準備
   - レート制限・エラーハンドリング
   - 自動バックアップ・アーカイブ

4. **セキュリティ**
   - LINE署名検証
   - 入力値サニタイゼーション
   - 権限ベースアクセス制御

5. **運用・監視**
   - ヘルスチェックAPI
   - 自動化されたジョブ管理
   - データ整合性チェック

この設計により、小規模チーム向けの保守しやすいシフト管理システムを実現できます。JSONベースから始めて、必要に応じてPostgreSQLに移行可能な柔軟性も確保しています。# LINE Bot シフト管理システム バックエンド設計書

## 目次
1. [アーキテクチャ概要](#アーキテクチャ概要)
2. [API設計](#api設計)
3. [データベース設計](#データベース設計)
4. [LINE Bot処理](#line-bot処理)
5. [バックグラウンド処理](#バックグラウンド処理)
6. [セキュリティ設計](#セキュリティ設計)
7. [デプロイ・運用](#デプロイ運用)

---

## アーキテクチャ概要

### システム構成
```
┌─────────────────────────────────────────┐
│              Frontend (Next.js)        │
│         ┌─────────────────────────────┐ │
│         │     表示専用Web画面          │ │
│         │  - シフト表表示             │ │
│         │  - PDF/画像出力             │ │
│         │  - 共有事項表示             │ │
│         └─────────────────────────────┘ │
└─────────────────┬───────────────────────┘
                  │ HTTP/REST API
┌─────────────────┴───────────────────────┐
│           Backend (Node.js/Express)    │
│  ┌─────────────┐  ┌─────────────────┐   │
│  │ API Routes  │  │ LINE Bot Engine │   │
│  │             │  │                 │   │
│  │ /api/shift  │  │ - Webhook       │   │
│  │ /api/pdf    │  │ - NLP Parser    │   │
│  │ /api/image  │  │ - State Manager │   │
│  │ /api/notice │  │ - Notification  │   │
│  └─────────────┘  └─────────────────┘   │
│         │                   │           │
│  ┌─────────────┐  ┌─────────────────┐   │
│  │ File System │  │ Scheduled Jobs  │   │
│  │             │  │                 │   │
│  │ JSON DB     │  │ - Daily Notify  │   │
│  │ File Cache  │  │ - Auto Backup   │   │
│  │ PDF/Images  │  │ - Data Archive  │   │
│  └─────────────┘  └─────────────────┘   │
└─────────────────┬───────────────────────┘
                  │ LINE Messaging API
┌─────────────────┴───────────────────────┐
│            LINE Platform                │
│  - Webhook Events                       │
│  - Message Sending                      │
│  - User Management                      │
└─────────────────────────────────────────┘
```

### 技術スタック
- **Runtime**: Node.js 18+
- **Framework**: Express.js
- **Database**: JSON Files (軽量・保守性重視)
- **External API**: LINE Messaging API
- **PDF生成**: Puppeteer
- **Scheduling**: node-cron
- **Deployment**: Vercel (サーバーレス)

---

## API設計

### 1. RESTful API エンドポイント

```typescript
// types/api.ts
export interface APIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  meta?: {
    timestamp: string;
    version: string;
  };
}

export interface PaginationParams {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface DateRangeParams {
  startDate?: string;
  endDate?: string;
}
```

#### シフト関連API
```typescript
// pages/api/shift/[date].ts
/*
GET /api/shift/[date]
- 指定日のシフト情報取得
- レスポンス: 
  - shifts: EnrichedShift[]
  - positions: Position[]
  - users: User[]
  - notices: Notice[]
  - dailyMessages: DailyMessage[]
*/

import { NextApiRequest, NextApiResponse } from 'next';
import { db } from '../../../lib/database';
import { validateDate, enrichShifts } from '../../../lib/utils';
import { APIResponse } from '../../../types/api';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>
) {
  try {
    const { date } = req.query;
    
    // バリデーション
    if (!validateDate(date as string)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_DATE',
          message: 'Invalid date format. Expected YYYY-MM-DD'
        }
      });
    }

    if (req.method === 'GET') {
      return await handleGetShift(req, res, date as string);
    }

    res.status(405).json({
      success: false,
      error: {
        code: 'METHOD_NOT_ALLOWED',
        message: `Method ${req.method} not allowed`
      }
    });
  } catch (error) {
    console.error('Shift API Error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Internal server error'
      }
    });
  }
}

async function handleGetShift(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>,
  date: string
) {
  // 並列データ取得
  const [shifts, notices, positions, users] = await Promise.all([
    db.getShifts(date),
    db.getActiveNotices(),
    db.getPositions(),
    db.getActiveUsers()
  ]);

  // 当日の場合は日次メッセージも取得
  const today = new Date().toISOString().split('T')[0];
  const dailyMessages = date === today ? await db.getDailyMessages(date) : [];

  // シフトデータの結合・拡張
  const enrichedShifts = enrichShifts(shifts, users, positions);

  res.status(200).json({
    success: true,
    data: {
      date,
      shifts: enrichedShifts,
      notices,
      positions,
      users,
      dailyMessages,
      isToday: date === today
    },
    meta: {
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    }
  });
}
```

#### 月間シフトAPI
```typescript
// pages/api/shift/month/[month].ts
/*
GET /api/shift/month/[month]
- 月間シフト情報取得
- クエリパラメータ:
  - userId?: string (特定ユーザーのみ)
  - positionId?: string (特定ポジションのみ)
  - status?: 'draft' | 'confirmed' (ステータス絞り込み)
*/

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>
) {
  try {
    const { month } = req.query;
    const { userId, positionId, status } = req.query;

    if (!validateMonth(month as string)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_MONTH',
          message: 'Invalid month format. Expected YYYY-MM'
        }
      });
    }

    if (req.method === 'GET') {
      return await handleGetMonthlyShifts(req, res, {
        month: month as string,
        userId: userId as string,
        positionId: positionId as string,
        status: status as string
      });
    }

    res.status(405).json({
      success: false,
      error: {
        code: 'METHOD_NOT_ALLOWED',
        message: `Method ${req.method} not allowed`
      }
    });
  } catch (error) {
    console.error('Monthly Shift API Error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Internal server error'
      }
    });
  }
}

async function handleGetMonthlyShifts(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>,
  filters: {
    month: string;
    userId?: string;
    positionId?: string;
    status?: string;
  }
) {
  const monthlyShifts = await db.getMonthlyShifts(filters.month);
  
  // フィルタリング
  let filteredShifts = monthlyShifts;
  
  if (filters.userId) {
    filteredShifts = filteredShifts.filter(shift => shift.userId === filters.userId);
  }
  
  if (filters.positionId) {
    filteredShifts = filteredShifts.filter(shift => shift.positionId === filters.positionId);
  }
  
  if (filters.status) {
    filteredShifts = filteredShifts.filter(shift => shift.status === filters.status);
  }

  // 統計情報計算
  const statistics = calculateMonthlyStatistics(filteredShifts);

  res.status(200).json({
    success: true,
    data: {
      month: filters.month,
      shifts: filteredShifts,
      statistics,
      filters
    }
  });
}
```

#### PDF/画像出力API
```typescript
// pages/api/pdf/[date].ts
/*
GET /api/pdf/[date]
- シフト表PDF生成・出力
- クエリパラメータ:
  - format?: 'A4' | 'A3' | 'Letter'
  - orientation?: 'portrait' | 'landscape'
  - includeNotices?: boolean
*/

import puppeteer from 'puppeteer';
import { generateShiftHTML } from '../../../lib/pdf-generator';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { date } = req.query;
    const { 
      format = 'A4', 
      orientation = 'portrait',
      includeNotices = 'true'
    } = req.query;

    if (!validateDate(date as string)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_DATE',
          message: 'Invalid date format'
        }
      });
    }

    if (req.method === 'GET') {
      return await generatePDF(req, res, {
        date: date as string,
        format: format as string,
        orientation: orientation as 'portrait' | 'landscape',
        includeNotices: includeNotices === 'true'
      });
    }

    res.status(405).json({
      success: false,
      error: { code: 'METHOD_NOT_ALLOWED', message: 'Method not allowed' }
    });
  } catch (error) {
    console.error('PDF Generation Error:', error);
    res.status(500).json({
      success: false,
      error: { code: 'PDF_GENERATION_FAILED', message: 'PDF generation failed' }
    });
  }
}

async function generatePDF(
  req: NextApiRequest,
  res: NextApiResponse,
  options: {
    date: string;
    format: string;
    orientation: 'portrait' | 'landscape';
    includeNotices: boolean;
  }
) {
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });

  try {
    const page = await browser.newPage();
    
    // シフトデータ取得
    const shiftData = await getShiftDataForPDF(options.date, options.includeNotices);
    
    // HTML生成
    const html = generateShiftHTML(shiftData, options);
    
    await page.setContent(html, { waitUntil: 'networkidle0' });
    
    // PDF生成オプション
    const pdfOptions = {
      format: options.format as any,
      orientation: options.orientation,
      margin: {
        top: '20mm',
        right: '15mm',
        bottom: '20mm',
        left: '15mm'
      },
      printBackground: true,
      displayHeaderFooter: true,
      headerTemplate: generatePDFHeader(options.date),
      footerTemplate: generatePDFFooter()
    };

    const pdf = await page.pdf(pdfOptions);

    // レスポンスヘッダー設定
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="shift_${options.date}.pdf"`);
    res.setHeader('Cache-Control', 'public, max-age=3600'); // 1時間キャッシュ
    
    res.send(pdf);
  } finally {
    await browser.close();
  }
}
```

### 2. LINE Bot Webhook API

```typescript
// pages/api/webhook.ts
/*
POST /api/webhook
- LINE Webhook エンドポイント
- LINE署名検証
- メッセージ解析・レスポンス処理
*/

import { NextApiRequest, NextApiResponse } from 'next';
import { Client, middleware, MiddlewareConfig } from '@line/bot-sdk';
import { LineMentionHandler } from '../../lib/line-mention-handler';
import { validateLineSignature } from '../../lib/security';

const config: MiddlewareConfig = {
  channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN!,
  channelSecret: process.env.LINE_CHANNEL_SECRET!,
};

const client = new Client(config);
const mentionHandler = new LineMentionHandler(client);

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // LINE署名検証
    const signature = req.headers['x-line-signature'] as string;
    const body = JSON.stringify(req.body);
    
    if (!validateLineSignature(body, signature, config.channelSecret)) {
      console.error('Invalid LINE signature');
      return res.status(401).json({ error: 'Invalid signature' });
    }

    // Webhook イベント処理
    const events = req.body.events;
    
    await Promise.all(events.map(async (event: any) => {
      try {
        await handleLineEvent(event);
      } catch (error) {
        console.error('Event handling error:', error);
        // 個別イベントエラーはログのみ（全体は継続）
      }
    }));

    res.status(200).json({ success: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

async function handleLineEvent(event: any) {
  console.log('LINE Event:', JSON.stringify(event, null, 2));

  switch (event.type) {
    case 'message':
      if (event.message.type === 'text') {
        await mentionHandler.handleMessage(event);
      }
      break;
      
    case 'memberJoined':
      await handleMemberJoined(event);
      break;
      
    case 'memberLeft':
      await handleMemberLeft(event);
      break;
      
    case 'follow':
      await handleFollow(event);
      break;
      
    case 'unfollow':
      await handleUnfollow(event);
      break;
      
    default:
      console.log('Unhandled event type:', event.type);
  }
}

async function handleMemberJoined(event: any) {
  // 新メンバー自動登録
  for (const member of event.joined.members) {
    if (member.type === 'user') {
      try {
        const profile = await client.getProfile(member.userId);
        
        await db.saveUser(member.userId, {
          displayName: profile.displayName,
          role: 'staff',
          isActive: true,
          joinedAt: new Date().toISOString()
        });
        
        // ウェルカムメッセージ
        const welcomeMessage = generateWelcomeMessage(profile.displayName);
        await client.pushMessage(member.userId, {
          type: 'text',
          text: welcomeMessage
        });
        
        console.log(`New user registered: ${profile.displayName} (${member.userId})`);
      } catch (error) {
        console.error('Failed to handle member joined:', error);
      }
    }
  }
}

async function handleMemberLeft(event: any) {
  // メンバー退出処理
  for (const member of event.left.members) {
    if (member.type === 'user') {
      await db.deactivateUser(member.userId);
      console.log(`User deactivated: ${member.userId}`);
    }
  }
}
```

---

## データベース設計

### 1. JSON Database 実装

```typescript
// lib/database.ts
import fs from 'fs/promises';
import path from 'path';
import { DatabaseSchema, User, Shift, Notice, DailyMessage } from '../types/database';

export class JSONDatabase {
  private data: DatabaseSchema | null = null;
  private lastModified: Date | null = null;
  private readonly dbPath: string;
  private readonly backupDir: string;
  private isLoading = false;

  constructor() {
    this.dbPath = path.join(process.cwd(), 'data/database.json');
    this.backupDir = path.join(process.cwd(), 'data/backups');
  }

  // データ読み込み（排他制御付き）
  async load(): Promise<void> {
    if (this.isLoading) {
      // 同時読み込み防止
      await new Promise(resolve => setTimeout(resolve, 100));
      return this.load();
    }

    this.isLoading = true;
    
    try {
      const stats = await fs.stat(this.dbPath);
      
      if (!this.data || stats.mtime > this.lastModified) {
        const content = await fs.readFile(this.dbPath, 'utf8');
        this.data = JSON.parse(content);
        this.lastModified = stats.mtime;
        
        // データ整合性チェック
        this.validateDataIntegrity();
      }
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.log('Database file not found, creating initial data...');
        this.data = this.getInitialData();
        await this.save();
      } else {
        console.error('Database load error:', error);
        throw new Error('Failed to load database');
      }
    } finally {
      this.isLoading = false;
    }
  }

  // データ保存（バックアップ付き）
  async save(): Promise<void> {
    if (!this.data) {
      throw new Error('No data to save');
    }

    try {
      // メタデータ更新
      this.data.metadata.lastUpdatedAt = new Date().toISOString();
      this.data.metadata.version = '1.0.0';

      // バックアップ作成
      await this.createBackup();

      // メインファイル保存
      const tempPath = `${this.dbPath}.tmp`;
      await fs.writeFile(tempPath, JSON.stringify(this.data, null, 2));
      await fs.rename(tempPath, this.dbPath);
      
      this.lastModified = new Date();
      
      console.log('Database saved successfully');
    } catch (error) {
      console.error('Database save error:', error);
      throw new Error('Failed to save database');
    }
  }

  // バックアップ作成
  private async createBackup(): Promise<void> {
    try {
      await fs.mkdir(this.backupDir, { recursive: true });
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(this.backupDir, `backup_${timestamp}.json`);
      
      await fs.writeFile(backupPath, JSON.stringify(this.data, null, 2));
      
      // 古いバックアップ削除（30日以上）
      await this.cleanupOldBackups();
    } catch (error) {
      console.error('Backup creation failed:', error);
      // バックアップ失敗は警告レベル（メイン処理は継続）
    }
  }

  // 古いバックアップ削除
  private async cleanupOldBackups(): Promise<void> {
    try {
      const files = await fs.readdir(this.backupDir);
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      for (const file of files) {
        if (file.startsWith('backup_') && file.endsWith('.json')) {
          const filePath = path.join(this.backupDir, file);
          const stats = await fs.stat(filePath);
          
          if (stats.mtime < thirtyDaysAgo) {
            await fs.unlink(filePath);
            console.log(`Deleted old backup: ${file}`);
          }
        }
      }
    } catch (error) {
      console.error('Backup cleanup failed:', error);
    }
  }

  // データ整合性チェック
  private validateDataIntegrity(): void {
    if (!this.data) return;

    // 必須フィールドチェック
    const requiredKeys = ['users', 'positions', 'shifts', 'shiftRequests', 'sharedNotices', 'settings', 'metadata'];
    for (const key of requiredKeys) {
      if (!(key in this.data)) {
        console.warn(`Missing required field: ${key}`);
        this.data[key] = this.getDefaultValueForKey(key);
      }
    }

    // ユーザーデータの修復
    for (const [userId, user] of Object.entries(this.data.users)) {
      if (!user.lineUserId) {
        user.lineUserId = userId;
      }
      if (!user.joinedAt) {
        user.joinedAt = new Date().toISOString();
      }
    }

    console.log('Data integrity check completed');
  }

  // === 基本CRUD操作 ===

  // ユーザー操作
  async getUser(lineUserId: string): Promise<User | null> {
    await this.load();
    return this.data.users[lineUserId] || null;
  }

  async saveUser(lineUserId: string, userData: Partial<User>): Promise<User> {
    await this.load();
    
    const isNewUser = !this.data.users[lineUserId];
    
    this.data.users[lineUserId] = {
      lineUserId,
      displayName: '',
      role: 'staff',
      isActive: true,
      joinedAt: new Date().toISOString(),
      lastSeenAt: new Date().toISOString(),
      ...this.data.users[lineUserId],
      ...userData
    };

    if (isNewUser) {
      this.data.metadata.totalUsers += 1;
    }

    await this.save();
    return this.data.users[lineUserId];
  }

  async getActiveUsers(): Promise<User[]> {
    await this.load();
    return Object.values(this.data.users).filter(user => user.isActive);
  }

  async deactivateUser(lineUserId: string): Promise<void> {
    await this.load();
    
    if (this.data.users[lineUserId]) {
      this.data.users[lineUserId].isActive = false;
      this.data.users[lineUserId].leftAt = new Date().toISOString();
      await this.save();
    }
  }

  // シフト操作
  async getShifts(date: string): Promise<Shift[]> {
    await this.load();
    return this.data.shifts[date] || [];
  }

  async getMonthlyShifts(month: string): Promise<Shift[]> {
    await this.load();
    
    const monthlyShifts: Shift[] = [];
    
    // 該当月のすべての日付をチェック
    for (const [date, shifts] of Object.entries(this.data.shifts)) {
      if (date.startsWith(month)) {
        monthlyShifts.push(...shifts);
      }
    }
    
    return monthlyShifts;
  }

  async saveShift(date: string, shiftData: Omit<Shift, 'id' | 'createdAt'>): Promise<Shift> {
    await this.load();
    
    if (!this.data.shifts[date]) {
      this.data.shifts[date] = [];
    }

    const shift: Shift = {
      id: this.generateId('shift'),
      ...shiftData,
      createdAt: new Date().toISOString()
    };

    this.data.shifts[date].push(shift);
    this.data.metadata.totalShifts += 1;
    
    await this.save();
    return shift;
  }

  async updateShift(date: string, shiftId: string, updateData: Partial<Shift>): Promise<Shift | null> {
    await this.load();
    
    const shifts = this.data.shifts[date] || [];
    const shiftIndex = shifts.findIndex(s => s.id === shiftId);
    
    if (shiftIndex !== -1) {
      this.data.shifts[date][shiftIndex] = {
        ...this.data.shifts[date][shiftIndex],
        ...updateData,
        updatedAt: new Date().toISOString()
      };
      
      await this.save();
      return this.data.shifts[date][shiftIndex];
    }
    
    return null;
  }

  async deleteShift(date: string, shiftId: string): Promise<boolean> {
    await this.load();
    
    const shifts = this.data.shifts[date] || [];
    const initialLength = shifts.length;
    
    this.data.shifts[date] = shifts.filter(s => s.id !== shiftId);
    
    if (this.data.shifts[date].length < initialLength) {
      await this.save();
      return true;
    }
    
    return false;
  }

  // 共有事項操作
  async getActiveNotices(): Promise<Notice[]> {
    await this.load();
    
    const today = new Date().toISOString().split('T')[0];
    
    return this.data.sharedNotices.filter(notice => 
      notice.isActive && 
      notice.startDate <= today && 
      (!notice.endDate || notice.endDate >= today)
    );
  }

  async saveNotice(noticeData: Omit<Notice, 'id' | 'createdAt'>): Promise<Notice> {
    await this.load();

    const notice: Notice = {
      id: this.generateId('notice'),
      ...noticeData,
      isActive: true,
      createdAt: new Date().toISOString()
    };

    this.data.sharedNotices.push(notice);
    await this.save();
    
    return notice;
  }

  // === ユーティリティ ===

  private generateId(prefix: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${prefix}_${timestamp}_${random}`;
  }

  private getInitialData(): DatabaseSchema {
    return {
      users: {},
      positions: [
        { id: "pos_01", name: "洗い場", emoji: "🧽", sortOrder: 1 },
        { id: "pos_02", name: "1レーン", emoji: "🍽️", sortOrder: 2 },
        { id: "pos_03", name: "2レーン", emoji: "🍖", sortOrder: 3 },
        { id: "pos_04", name: "ホール", emoji: "🏃‍♀️", sortOrder: 4 }
      ],
      shifts: {},
      shiftRequests: {},
      sharedNotices: [],
      dailyMessages: {},
      settings: {
        storeName: "〇〇〇店",
        businessHours: "09:00-22:00",
        adminLineUserId: "",
        shiftDeadlineDay: 25,
        autoBreakEnabled: true,
        breakRules: { "6hours": 45, "8hours": 60 },
        timezone: "Asia/Tokyo"
      },
      substituteRequests: [],
      metadata: {
        version: "1.0.0",
        createdAt: new Date().toISOString(),
        lastUpdatedAt: new Date().toISOString(),
        totalUsers: 0,
        totalShifts: 0
      }
    };
  }

  private getDefaultValueForKey(key: string): any {
    const defaults = {
      users: {},
      positions: [],
      shifts: {},
      shiftRequests: {},
      sharedNotices: [],
      dailyMessages: {},
      settings: {},
      substituteRequests: [],
      metadata: {
        version: "1.0.0",
        createdAt: new Date().toISOString(),
        lastUpdatedAt: new Date().toISOString(),
        totalUsers: 0,
        totalShifts: 0
      }
    };
    
    return defaults[key] || {};
  }
}

// シングルトンインスタンス
export const db = new JSONDatabase();
```

### 2. データベーススキーマ定義

```typescript
// types/database.ts
export interface DatabaseSchema {
  users: Record<string, User>;
  positions: Position[];
  shifts: Record<string,