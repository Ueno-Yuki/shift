// types/database.ts
export interface DatabaseSchema {
  users: Record<string, User>;
  positions: Position[];
  shifts: Record<string, Shift[]>; // date -> Shift[]
  shiftRequests: Record<string, Record<string, ShiftRequest>>; // month -> userId -> ShiftRequest
  sharedNotices: Notice[];
  dailyMessages: Record<string, DailyMessage[]>; // date -> DailyMessage[]
  substituteRequests: SubstituteRequest[];
  settings: SystemSettings;
  metadata: DatabaseMetadata;
}

export interface User {
  lineUserId: string;
  displayName: string;
  realName?: string;
  role: 'admin' | 'staff';
  isActive: boolean;
  joinedAt: string;
  lastSeenAt: string;
  leftAt?: string;
  preferences?: {
    notifications: boolean;
    timezone: string;
  };
}

export interface Position {
  id: string;
  name: string;
  emoji: string;
  sortOrder: number;
  requiredStaff?: Record<string, number>; // hour -> required count
}

export interface Shift {
  id: string;
  userId: string;
  positionId: string;
  startTime: string; // HH:MM
  endTime: string;   // HH:MM
  breakMinutes: number;
  status: 'draft' | 'preview' | 'confirmed' | 'locked';
  createdAt: string;
  updatedAt?: string;
  createdBy?: string;
  notes?: string;
}

export interface ShiftRequest {
  month: string;
  userId: string;
  requestText: string;
  parsedData: ParsedShiftData;
  submittedAt: string;
  status: 'submitted' | 'processed';
  notes?: string;
}

export interface ParsedShiftData {
  weekdays?: {
    available: boolean;
    preferredStart?: string;
    preferredEnd?: string;
  };
  weekends?: {
    available: boolean;
    preferredStart?: string;
    preferredEnd?: string;
  };
  specificDays?: string[];
  unavailableDates?: string[];
  notes?: string[];
}

export interface Notice {
  id: string;
  title: string;
  content: string;
  category: 'equipment' | 'staff' | 'operation' | 'other';
  priority: 'low' | 'medium' | 'high' | 'urgent';
  startDate: string;
  endDate?: string;
  isActive: boolean;
  createdBy: string;
  createdAt: string;
  updatedAt?: string;
}

export interface DailyMessage {
  id: string;
  userName: string;
  message: string;
  messageType: 'chat' | 'line_import' | 'admin_memo' | 'system';
  isPrivate: boolean;
  createdAt: string;
  userId?: string;
}

export interface SubstituteRequest {
  id: string;
  shiftId?: string;
  requesterId: string;
  substituteId?: string;
  targetDate: string;
  reason: string;
  status: 'pending' | 'accepted' | 'rejected' | 'cancelled';
  requestedAt: string;
  respondedAt?: string;
  notes?: string;
}

export interface SystemSettings {
  storeName: string;
  businessHours: string;
  adminLineUserId: string;
  shiftDeadlineDay: number;
  autoBreakEnabled: boolean;
  breakRules: Record<string, number>;
  timezone: string;
  specialEvents?: SpecialEvent[];
  dynamicHolidays?: Record<string, Record<string, any>>;
}

export interface SpecialEvent {
  id: string;
  name: string;
  startDate: string;
  endDate: string;
  additionalStaff: Record<string, number>; // positionId -> additional count
  description?: string;
  isActive: boolean;
  createdAt: string;
}

export interface DatabaseMetadata {
  version: string;
  createdAt: string;
  lastUpdatedAt: string;
  totalUsers: number;
  totalShifts: number;
  lastBackupAt?: string;
}
```

---

## LINE Botå‡¦ç†

### 1. ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³å‡¦ç†ã‚¨ãƒ³ã‚¸ãƒ³

```typescript
// lib/line-mention-handler.ts
import { Client } from '@line/bot-sdk';
import { MentionParser } from './nlp/mention-parser';
import { ShiftStateManager } from './shift-state-manager';
import { NotificationManager } from './notification-manager';
import { db } from './database';

export class LineMentionHandler {
  private client: Client;
  private mentionParser: MentionParser;
  private stateManager: ShiftStateManager;
  private notificationManager: NotificationManager;

  constructor(lineClient: Client) {
    this.client = lineClient;
    this.mentionParser = new MentionParser();
    this.stateManager = new ShiftStateManager(db);
    this.notificationManager = new NotificationManager(lineClient, db);
  }

  async handleMessage(event: any): Promise<void> {
    const messageText = event.message.text;
    const lineUserId = event.source.userId;
    const replyToken = event.replyToken;

    try {
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±å–å¾—ãƒ»æ›´æ–°
      const user = await this.getOrCreateUser(lineUserId);
      
      // ã‚¢ã‚¯ãƒ†ã‚£ãƒ“ãƒ†ã‚£æ›´æ–°
      await db.saveUser(lineUserId, { 
        lastSeenAt: new Date().toISOString() 
      });

      // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³è§£æ
      const parsed = this.mentionParser.parse(messageText, user);

      if (!parsed) {
        // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ãªã—ã®å ´åˆã¯æ—¥å¸¸ä¼šè©±ã¨ã—ã¦å‡¦ç†
        return await this.handleChatMessage(messageText, user, event);
      }

      // ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒã‚§ãƒƒã‚¯
      if (!await this.checkRateLimit(lineUserId)) {
        return await this.replyMessage(replyToken, 
          'ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚ã—ã°ã‚‰ãæ™‚é–“ã‚’ãŠã„ã¦ã‹ã‚‰å†åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
      }

      // æ„å›³åˆ¥å‡¦ç†
      await this.handleIntent(parsed, event);

    } catch (error) {
      console.error('Message handling error:', error);
      await this.replyMessage(replyToken, 
        'ç”³ã—è¨³ã”ã–ã„ã¾ã›ã‚“ã€‚ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚\nç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚');
    }
  }

  private async getOrCreateUser(lineUserId: string): Promise<User> {
    let user = await db.getUser(lineUserId);
    
    if (!user) {
      // æ–°è¦ãƒ¦ãƒ¼ã‚¶ãƒ¼ã®å ´åˆã¯ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å–å¾—ã—ã¦ç™»éŒ²
      try {
        const profile = await this.client.getProfile(lineUserId);
        user = await db.saveUser(lineUserId, {
          displayName: profile.displayName,
          role: 'staff',
          isActive: true
        });
        
        // ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡
        await this.sendWelcomeMessage(lineUserId, profile.displayName);
      } catch (error) {
        console.error('Failed to get user profile:', error);
        // ãƒ—ãƒ­ãƒ•ã‚£ãƒ¼ãƒ«å–å¾—å¤±æ•—æ™‚ã¯æœ€ä½é™ã®ãƒ¦ãƒ¼ã‚¶ãƒ¼æƒ…å ±ã§ç™»éŒ²
        user = await db.saveUser(lineUserId, {
          displayName: 'Unknown User',
          role: 'staff',
          isActive: true
        });
      }
    }
    
    return user;
  }

  private async handleIntent(parsed: any, event: any): Promise<void> {
    const { intent, parameters, user } = parsed;

    switch (intent) {
      case 'shiftQuery':
        await this.handleShiftQuery(parameters, user, event);
        break;
      case 'shiftRequest':
        await this.handleShiftRequest(parameters, user, event);
        break;
      case 'changeRequest':
        await this.handleChangeRequest(parameters, user, event);
        break;
      case 'pdfRequest':
        await this.handlePdfRequest(parameters, user, event);
        break;
      case 'noticeQuery':
        await this.handleNoticeQuery(parameters, user, event);
        break;
      case 'helpRequest':
        await this.handleHelpRequest(user, event);
        break;
      
      // ç®¡ç†è€…å°‚ç”¨æ©Ÿèƒ½
      case 'adminPreview':
        await this.handleAdminPreview(parameters, user, event);
        break;
      case 'adminConfirm':
        await this.handleAdminConfirm(parameters, user, event);
        break;
      case 'adminAssign':
        await this.handleAdminAssign(parameters, user, event);
        break;
      case 'eventManagement':
        await this.handleEventManagement(parameters, user, event);
        break;
        
      default:
        await this.handleUnknownIntent(parsed, event);
    }
  }

  // === æ„å›³åˆ¥ãƒãƒ³ãƒ‰ãƒ©ãƒ¼ ===

  private async handleShiftRequest(params: any, user: User, event: any): Promise<void> {
    if (user.role !== 'admin' && user.role !== 'staff') {
      return await this.replyMessage(event.replyToken, 
        'âš ï¸ ã‚·ãƒ•ãƒˆæå‡ºæ¨©é™ãŒã‚ã‚Šã¾ã›ã‚“ã€‚ç®¡ç†è€…ã«ãŠå•ã„åˆã‚ã›ãã ã•ã„ã€‚');
    }

    try {
      // ã‚·ãƒ•ãƒˆå¸Œæœ›ãƒ‡ãƒ¼ã‚¿ã®æ§‹é€ åŒ–
      const shiftRequestData = {
        month: params.month || this.getNextMonth(),
        userId: user.lineUserId,
        requestText: event.message.text,
        parsedData: {
          weekdays: params.weekdays,
          weekends: params.weekends,
          timeRange: params.timeRange,
          specificDays: params.specificDays,
          notes: params.notes || []
        },
        submittedAt: new Date().toISOString(),
        status: 'submitted' as const
      };

      // ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’ä¿å­˜
      await this.saveShiftRequest(shiftRequestData);

      // ä»®ã‚·ãƒ•ãƒˆè‡ªå‹•ç”Ÿæˆ
      await this.stateManager.generatePreviewShift(shiftRequestData.month);

      // ç¢ºèªãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      const response = this.formatShiftRequestResponse(shiftRequestData);
      await this.replyMessage(event.replyToken, response);

      // ç®¡ç†è€…ã«é€šçŸ¥
      await this.notificationManager.notifyShiftRequestSubmitted(user, shiftRequestData);

    } catch (error) {
      console.error('Shift request handling error:', error);
      await this.replyMessage(event.replyToken, 
        'ã‚·ãƒ•ãƒˆå¸Œæœ›ã®å‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚ã‚‚ã†ä¸€åº¦ãŠè©¦ã—ãã ã•ã„ã€‚');
    }
  }

  private async handleAdminPreview(params: any, user: User, event: any): Promise<void> {
    if (user.role !== 'admin') {
      return await this.replyMessage(event.replyToken, 
        'âš ï¸ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚');
    }

    try {
      const targetMonth = params.month || this.getNextMonth();
      
      // ä»®ã‚·ãƒ•ãƒˆçŠ¶æ³åˆ†æ
      const analysis = await this.stateManager.analyzeShiftCoverage(targetMonth);
      
      // åˆ†æçµæœã‚’ãƒ•ã‚©ãƒ¼ãƒãƒƒãƒˆ
      const response = this.formatShiftAnalysisResponse(targetMonth, analysis);
      
      await this.replyMessage(event.replyToken, response);
      
    } catch (error) {
      console.error('Admin preview error:', error);
      await this.replyMessage(event.replyToken, 
        'ä»®ã‚·ãƒ•ãƒˆåˆ†æä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    }
  }

  private async handleAdminConfirm(params: any, user: User, event: any): Promise<void> {
    if (user.role !== 'admin') {
      return await this.replyMessage(event.replyToken, 
        'âš ï¸ ç®¡ç†è€…æ¨©é™ãŒå¿…è¦ã§ã™ã€‚');
    }

    try {
      const targetMonth = params.month || this.getNextMonth();
      
      // é‡å¤§ãªäººæ‰‹ä¸è¶³ãƒã‚§ãƒƒã‚¯
      const criticalShortages = await this.stateManager.checkCriticalShortages(targetMonth);
      
      if (criticalShortages.length > 0 && !params.forceConfirm) {
        const warningMessage = this.formatShortageWarning(criticalShortages);
        return await this.replyMessage(event.replyToken, warningMessage);
      }

      // ã‚·ãƒ•ãƒˆç¢ºå®šå‡¦ç†
      await this.stateManager.confirmShifts(targetMonth, user.lineUserId);
      
      // å…¨ã‚¹ã‚¿ãƒƒãƒ•ã«é€šçŸ¥
      await this.notificationManager.notifyShiftConfirmed(targetMonth);
      
      const response = `ğŸ”’ **${targetMonth} ã‚·ãƒ•ãƒˆç¢ºå®šå®Œäº†**\n\n` +
                      `ã™ã¹ã¦ã®ã‚¹ã‚¿ãƒƒãƒ•ã«ç¢ºå®šé€šçŸ¥ã‚’é€ä¿¡ã—ã¾ã—ãŸã€‚`;
      
      await this.replyMessage(event.replyToken, response);
      
    } catch (error) {
      console.error('Shift confirmation error:', error);
      await this.replyMessage(event.replyToken, 
        'ã‚·ãƒ•ãƒˆç¢ºå®šå‡¦ç†ä¸­ã«ã‚¨ãƒ©ãƒ¼ãŒç™ºç”Ÿã—ã¾ã—ãŸã€‚');
    }
  }

  // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ãƒ¡ã‚½ãƒƒãƒ‰ ===

  private async saveShiftRequest(requestData: any): Promise<void> {
    if (!db.data.shiftRequests[requestData.month]) {
      db.data.shiftRequests[requestData.month] = {};
    }
    
    db.data.shiftRequests[requestData.month][requestData.userId] = requestData;
    await db.save();
  }

  private formatShiftRequestResponse(requestData: any): string {
    return `âœ… ã‚·ãƒ•ãƒˆå¸Œæœ›ã‚’å—ã‘ä»˜ã‘ã¾ã—ãŸï¼

ğŸ“… **å¯¾è±¡æœˆ**: ${requestData.month}
â° **å¸Œæœ›æ™‚é–“**: ${this.formatTimePreferences(requestData.parsedData)}
ğŸ“‹ **æ›œæ—¥è¨­å®š**: ${this.formatDayPreferences(requestData.parsedData)}

ğŸ”„ ä»®ã‚·ãƒ•ãƒˆã«è‡ªå‹•åæ˜ ã—ã¾ã—ãŸã€‚
è²¬ä»»è€…ã«ã‚ˆã‚‹ç¢ºå®šã‚’ãŠå¾…ã¡ãã ã•ã„ã€‚

ğŸ“± ã‚·ãƒ•ãƒˆç¢ºèª: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆ`;
  }

  private formatTimePreferences(parsedData: any): string {
    if (parsedData.timeRange) {
      return `${parsedData.timeRange.start} - ${parsedData.timeRange.end}`;
    }
    return 'æœªæŒ‡å®š';
  }

  private formatDayPreferences(parsedData: any): string {
    const parts = [];
    if (parsedData.weekdays?.available) parts.push('å¹³æ—¥OK');
    if (parsedData.weekends?.available === false) parts.push('åœŸæ—¥ä¼‘ã¿');
    if (parsedData.weekends?.available === true) parts.push('åœŸæ—¥OK');
    return parts.length > 0 ? parts.join(', ') : 'æœªæŒ‡å®š';
  }

  private async replyMessage(replyToken: string, text: string): Promise<void> {
    try {
      await this.client.replyMessage(replyToken, {
        type: 'text',
        text: text
      });
    } catch (error) {
      console.error('Reply message error:', error);
    }
  }

  private async checkRateLimit(userId: string): Promise<boolean> {
    // ç°¡æ˜“ãƒ¬ãƒ¼ãƒˆåˆ¶é™ï¼ˆãƒ¡ãƒ¢ãƒªãƒ™ãƒ¼ã‚¹ï¼‰
    // æœ¬æ ¼é‹ç”¨æ™‚ã¯Redisãªã©ã‚’ä½¿ç”¨
    return true; // æš«å®šçš„ã«å¸¸ã«true
  }

  private getNextMonth(): string {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    return nextMonth.toISOString().slice(0, 7);
  }
}
```

### 2. è‡ªç„¶è¨€èªå‡¦ç†ï¼ˆç°¡æ˜“ç‰ˆï¼‰

```typescript
// lib/nlp/mention-parser.ts
export class MentionParser {
  private botMentions = ['@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ', '@ã‚·ãƒ•ãƒˆ', '@shift', '@bot'];
  
  private intentPatterns = {
    // ã‚·ãƒ•ãƒˆç¢ºèªç³»
    shiftQuery: [
      /(ä»Šæœˆ|å½“æœˆ|ä»Šæ—¥|æ˜æ—¥|æ¥é€±|æ¥æœˆ)ã®?ã‚·ãƒ•ãƒˆ/,
      /ã‚·ãƒ•ãƒˆ.*?(ç¢ºèª|æ•™ãˆã¦|è¦‹ã›ã¦|è¡¨ç¤º)/,
      /(æ˜æ—¥|ä»Šæ—¥).*?(å‹¤å‹™|ã‚·ãƒ•ãƒˆ)/,
      /(\d+)æœˆ(\d+)æ—¥.*?ã‚·ãƒ•ãƒˆ/
    ],
    
    // ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡º
    shiftRequest: [
      /(æ¥æœˆ|å†æ¥æœˆ|\d+æœˆ).*?å¸Œæœ›/,
      /ã‚·ãƒ•ãƒˆ.*?å¸Œæœ›/,
      /(å¹³æ—¥|åœŸæ—¥|é€±æœ«).*?(æ™‚é–“|å‹¤å‹™)/,
      /(\d{1,2})æ™‚.*?(\d{1,2})æ™‚/
    ],
    
    // ã‚·ãƒ•ãƒˆå¤‰æ›´å¸Œæœ›
    changeRequest: [
      /(ä»£ã‚ã£ã¦|äº¤ä»£|å¤‰æ›´).*?(ã‚‚ã‚‰ãˆ|ã—ã¦|ãŠé¡˜ã„)/,
      /(ä¼‘ã¿|ãŠä¼‘ã¿).*?(ã‚‚ã‚‰ãˆ|ã—ãŸã„|ãŠé¡˜ã„)/,
      /(æ€¥ç”¨|ç”¨äº‹|ä½“èª¿).*?(ä»£ã‚ã‚Š|äº¤ä»£)/
    ],
    
    // PDFãƒ»ç”»åƒè¦æ±‚
    pdfRequest: [
      /(PDF|pdf).*?(æ¬²ã—ã„|ä¸‹ã•ã„|ãã ã•ã„)/,
      /(ç”»åƒ|å†™çœŸ).*?(æ¬²ã—ã„|ä¸‹ã•ã„|ä¿å­˜)/,
      /ã‚·ãƒ•ãƒˆè¡¨.*?(ä¿å­˜|ãƒ€ã‚¦ãƒ³ãƒ­ãƒ¼ãƒ‰)/
    ],
    
    // ãƒ˜ãƒ«ãƒ—
    helpRequest: [
      /(ä½¿ã„æ–¹|æ“ä½œ|æ–¹æ³•).*?(æ•™ãˆã¦|åˆ†ã‹ã‚‰ãªã„)/,
      /(ä½•|ã©ã†).*?(ã§ãã‚‹|ã™ã‚‹)/,
      /(ãƒ˜ãƒ«ãƒ—|help)/
    ],
    
    // ç®¡ç†è€…æ©Ÿèƒ½
    adminPreview: [
      /(ä»®|ãƒ—ãƒ¬ãƒ“ãƒ¥ãƒ¼).*?ã‚·ãƒ•ãƒˆ.*?(è¦‹ã›ã¦|ç¢ºèª|è¡¨ç¤º)/,
      /(æ¥æœˆ|ä»Šæœˆ).*?(çŠ¶æ³|æ§˜å­).*?(ç¢ºèª|æ•™ãˆã¦)/
    ],
    
    adminConfirm: [
      /(ã‚·ãƒ•ãƒˆ|æ¥æœˆ).*?(ç¢ºå®š|æ±ºå®š).*?(ã—ã¦|ãŠé¡˜ã„)/,
      /(ç¢ºå®š|æ±ºå®š).*?ã‚·ãƒ•ãƒˆ/
    ]
  };

  parse(text: string, user: any): any {
    // @ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³ã®ç¢ºèª
    const mention = this.extractMention(text);
    if (!mention) return null;

    // ãƒ¡ãƒ³ã‚·ãƒ§ãƒ³éƒ¨åˆ†ã‚’é™¤å»
    const cleanText = this.removeMention(text);

    // æ„å›³ã‚’åˆ†æ
    const intent = this.analyzeIntent(cleanText);

    // ãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿ã‚’æŠ½å‡º
    const parameters = this.extractParameters(cleanText, intent);

    return {
      type: 'mention',
      mention,
      originalText: text,
      cleanText,
      intent,
      parameters,
      confidence: this.calculateConfidence(cleanText, intent),
      user
    };
  }

  private extractMention(text: string): string | null {
    for (const mention of this.botMentions) {
      if (text.includes(mention)) {
        return mention;
      }
    }
    return null;
  }

  private removeMention(text: string): string {
    let cleanText = text;
    for (const mention of this.botMentions) {
      cleanText = cleanText.replace(mention, '').trim();
    }
    return cleanText;
  }

  private analyzeIntent(text: string): string {
    for (const [intent, patterns] of Object.entries(this.intentPatterns)) {
      for (const pattern of patterns) {
        if (pattern.test(text)) {
          return intent;
        }
      }
    }
    return 'general';
  }

  private extractParameters(text: string, intent: string): any {
    const params: any = {};

    switch (intent) {
      case 'shiftRequest':
        params.timeRange = this.extractTimeRange(text);
        params.weekdays = this.extractWeekdayPreference(text);
        params.weekends = this.extractWeekendPreference(text);
        params.month = this.extractMonth(text);
        break;
        
      case 'shiftQuery':
        params.period = this.extractTimePeriod(text);
        params.date = this.extractSpecificDate(text);
        break;
        
      case 'changeRequest':
        params.targetDate = this.extractSpecificDate(text);
        params.reason = this.extractReason(text);
        break;
    }

    return params;
  }

  private extractTimeRange(text: string): any {
    const timePattern = /(\d{1,2})æ™‚.*?(\d{1,2})æ™‚/;
    const match = text.match(timePattern);
    
    if (match) {
      return {
        start: `${match[1].padStart(2, '0')}:00`,
        end: `${match[2].padStart(2, '0')}:00`
      };
    }
    return null;
  }

  private extractWeekdayPreference(text: string): any {
    if (text.includes('å¹³æ—¥')) {
      return { available: true };
    }
    return null;
  }

  private extractWeekendPreference(text: string): any {
    if (text.includes('åœŸæ—¥')) {
      const isUnavailable = text.includes('ä¼‘ã¿') || text.includes('NG');
      return { available: !isUnavailable };
    }
    return null;
  }

  private extractMonth(text: string): string | null {
    if (text.includes('æ¥æœˆ')) {
      const now = new Date();
      const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
      return nextMonth.toISOString().slice(0, 7);
    }
    return null;
  }

  private extractTimePeriod(text: string): string | null {
    if (text.includes('ä»Šæœˆ') || text.includes('å½“æœˆ')) return 'current_month';
    if (text.includes('æ¥æœˆ')) return 'next_month';
    if (text.includes('ä»Šæ—¥')) return 'today';
    if (text.includes('æ˜æ—¥')) return 'tomorrow';
    return null;
  }

  private extractSpecificDate(text: string): string | null {
    const datePattern = /(\d+)æœˆ(\d+)æ—¥/;
    const match = text.match(datePattern);
    
    if (match) {
      const month = match[1].padStart(2, '0');
      const day = match[2].padStart(2, '0');
      return `${new Date().getFullYear()}-${month}-${day}`;
    }
    return null;
  }

  private extractReason(text: string): string {
    if (text.includes('ä½“èª¿') || text.includes('é¢¨é‚ª')) return 'ä½“èª¿ä¸è‰¯';
    if (text.includes('ç”¨äº‹') || text.includes('äºˆå®š')) return 'ç§ç”¨';
    if (text.includes('æ€¥')) return 'æ€¥ç”¨';
    return 'æœªæŒ‡å®š';
  }

  private calculateConfidence(text: string, intent: string): number {
    const patterns = this.intentPatterns[intent] || [];
    let confidence = 0;
    
    for (const pattern of patterns) {
      if (pattern.test(text)) {
        confidence = Math.max(confidence, 0.8);
      }
    }
    
    return confidence;
  }
}
```

---

## ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†

### 1. å®šæœŸå®Ÿè¡Œã‚¸ãƒ§ãƒ–

```typescript
// lib/scheduled-jobs.ts
import cron from 'node-cron';
import { db } from './database';
import { NotificationManager } from './notification-manager';

export class ScheduledJobManager {
  private notificationManager: NotificationManager;

  constructor(lineClient: any) {
    this.notificationManager = new NotificationManager(lineClient, db);
    this.initializeJobs();
  }

  private initializeJobs(): void {
    // æ¯æ—¥20:00ã«ç¿Œæ—¥ã®ã‚·ãƒ•ãƒˆé€šçŸ¥
    cron.schedule('0 20 * * *', async () => {
      await this.sendDailyShiftNotification();
    }, {
      timezone: 'Asia/Tokyo'
    });

    // æ¯æœˆ25æ—¥20:00ã«ã‚·ãƒ•ãƒˆæå‡ºå‚¬ä¿ƒ
    cron.schedule('0 20 25 * *', async () => {
      await this.sendShiftSubmissionReminder();
    }, {
      timezone: 'Asia/Tokyo'
    });

    // æ¯æ—¥2:00ã«ãƒ‡ãƒ¼ã‚¿ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—
    cron.schedule('0 2 * * *', async () => {
      await this.performDailyBackup();
    }, {
      timezone: 'Asia/Tokyo'
    });

    // æ¯æœˆ1æ—¥3:00ã«ãƒ‡ãƒ¼ã‚¿ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    cron.schedule('0 3 1 * *', async () => {
      await this.performMonthlyArchive();
    }, {
      timezone: 'Asia/Tokyo'
    });

    console.log('Scheduled jobs initialized');
  }

  private async sendDailyShiftNotification(): Promise<void> {
    try {
      const tomorrow = new Date();
      tomorrow.setDate(tomorrow.getDate() + 1);
      const tomorrowStr = tomorrow.toISOString().split('T')[0];

      const shifts = await db.getShifts(tomorrowStr);
      const activeUsers = await db.getActiveUsers();
      const positions = await db.getPositions();

      // æ˜æ—¥ã‚·ãƒ•ãƒˆãŒã‚ã‚‹ãƒ¦ãƒ¼ã‚¶ãƒ¼ã«é€šçŸ¥
      const notifications = [];
      
      for (const user of activeUsers) {
        const userShifts = shifts.filter(s => s.userId === user.lineUserId);
        
        if (userShifts.length > 0) {
          const message = this.formatTomorrowShiftMessage(userShifts, positions, tomorrowStr);
          notifications.push(
            this.notificationManager.sendPersonalNotification(user.lineUserId, message)
          );
        }
      }

      await Promise.all(notifications);
      console.log(`Daily shift notifications sent to ${notifications.length} users`);
      
    } catch (error) {
      console.error('Daily shift notification error:', error);
    }
  }

  private async sendShiftSubmissionReminder(): Promise<void> {
    try {
      const nextMonth = this.getNextMonth();
      const activeUsers = await db.getActiveUsers();
      const submittedUsers = await this.getSubmittedUsers(nextMonth);

      // æœªæå‡ºãƒ¦ãƒ¼ã‚¶ãƒ¼ã«å‚¬ä¿ƒ
      const reminderPromises = [];
      
      for (const user of activeUsers) {
        if (user.role === 'staff' && !submittedUsers.has(user.lineUserId)) {
          const message = this.formatSubmissionReminderMessage(nextMonth);
          reminderPromises.push(
            this.notificationManager.sendPersonalNotification(user.lineUserId, message)
          );
        }
      }

      await Promise.all(reminderPromises);
      console.log(`Submission reminders sent to ${reminderPromises.length} users`);
      
    } catch (error) {
      console.error('Submission reminder error:', error);
    }
  }

  private async performDailyBackup(): Promise<void> {
    try {
      // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã®çŠ¶æ…‹ã‚’å¼·åˆ¶ä¿å­˜ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒˆãƒªã‚¬ãƒ¼ï¼‰
      await db.save();
      
      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—æˆåŠŸã‚’ãƒ­ã‚°
      console.log('Daily backup completed');
      
    } catch (error) {
      console.error('Daily backup error:', error);
    }
  }

  private async performMonthlyArchive(): Promise<void> {
    try {
      // 6ãƒ¶æœˆä»¥ä¸Šå‰ã®ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
      const sixMonthsAgo = new Date();
      sixMonthsAgo.setMonth(sixMonthsAgo.getMonth() - 6);
      const cutoffDate = sixMonthsAgo.toISOString().split('T')[0];

      await this.archiveOldData(cutoffDate);
      console.log('Monthly archive completed');
      
    } catch (error) {
      console.error('Monthly archive error:', error);
    }
  }

  private formatTomorrowShiftMessage(shifts: any[], positions: any[], date: string): string {
    const dayOfWeek = this.getDayOfWeek(date);
    let message = `ğŸŒ… **æ˜æ—¥ã®ã‚·ãƒ•ãƒˆã®ãŠçŸ¥ã‚‰ã›**\n\n`;
    message += `ğŸ“… ${date} (${dayOfWeek})\n\n`;

    for (const shift of shifts) {
      const position = positions.find(p => p.id === shift.positionId);
      message += `${position?.emoji || 'ğŸ“'} **${position?.name || 'Unknown'}**\n`;
      message += `â° ${shift.startTime} - ${shift.endTime}\n`;
      if (shift.breakMinutes > 0) {
        message += `â˜• ä¼‘æ†©: ${shift.breakMinutes}åˆ†\n`;
      }
      message += `\n`;
    }

    message += `ğŸ’ª ãŠç–²ã‚Œã•ã¾ã§ã™ï¼æ˜æ—¥ã‚‚ã‚ˆã‚ã—ããŠé¡˜ã„ã—ã¾ã™ã€‚\n\n`;
    message += `â“ ä½•ã‹å¤‰æ›´ãŒã‚ã‚‹å ´åˆã¯ã€@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã«ã”é€£çµ¡ãã ã•ã„ã€‚`;

    return message;
  }

  private formatSubmissionReminderMessage(month: string): string {
    return `ğŸ“ **ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡ºã®ãŠçŸ¥ã‚‰ã›**

${month}ã®ã‚·ãƒ•ãƒˆå¸Œæœ›ãŒã¾ã æå‡ºã•ã‚Œã¦ã„ã¾ã›ã‚“ã€‚

ğŸ—“ï¸ **æå‡ºæœŸé™**: ä»Šæ—¥ã¾ã§
ğŸ“± **æå‡ºæ–¹æ³•**: @ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆå¸Œæœ›ã§ã™

ä¾‹ï¼š
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆå¸Œæœ›ã§ã™ã€‚å¹³æ—¥9æ™‚ã‹ã‚‰17æ™‚ã€åœŸæ—¥ä¼‘ã¿

ãŠå¿™ã—ã„ã¨ã¯æ€ã„ã¾ã™ãŒã€ã‚·ãƒ•ãƒˆä½œæˆã®ãŸã‚æ—©ã‚ã®æå‡ºã‚’ãŠé¡˜ã„ã„ãŸã—ã¾ã™ã€‚`;
  }

  private async getSubmittedUsers(month: string): Promise<Set<string>> {
    await db.load();
    const requests = db.data.shiftRequests[month] || {};
    return new Set(Object.keys(requests));
  }

  private getNextMonth(): string {
    const now = new Date();
    const nextMonth = new Date(now.getFullYear(), now.getMonth() + 1, 1);
    return nextMonth.toISOString().slice(0, 7);
  }

  private getDayOfWeek(date: string): string {
    const days = ['æ—¥', 'æœˆ', 'ç«', 'æ°´', 'æœ¨', 'é‡‘', 'åœŸ'];
    return days[new Date(date).getDay()];
  }

  private async archiveOldData(cutoffDate: string): Promise<void> {
    await db.load();
    
    const archiveData = {
      shifts: {},
      dailyMessages: {},
      archivedAt: new Date().toISOString()
    };

    // å¤ã„ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    for (const [date, shifts] of Object.entries(db.data.shifts)) {
      if (date < cutoffDate) {
        archiveData.shifts[date] = shifts;
        delete db.data.shifts[date];
      }
    }

    // å¤ã„ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ãƒ‡ãƒ¼ã‚¿ã‚’ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–
    for (const [date, messages] of Object.entries(db.data.dailyMessages)) {
      if (date < cutoffDate) {
        archiveData.dailyMessages[date] = messages;
        delete db.data.dailyMessages[date];
      }
    }

    // ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
    if (Object.keys(archiveData.shifts).length > 0 || Object.keys(archiveData.dailyMessages).length > 0) {
      const archivePath = path.join(process.cwd(), `data/archives/archive_${cutoffDate}.json`);
      await fs.mkdir(path.dirname(archivePath), { recursive: true });
      await fs.writeFile(archivePath, JSON.stringify(archiveData, null, 2));
      
      // ãƒ¡ã‚¤ãƒ³ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ä¿å­˜
      await db.save();
      
      console.log(`Archived data before ${cutoffDate}`);
    }
  }
}
```

### 2. é€šçŸ¥ç®¡ç†ã‚·ã‚¹ãƒ†ãƒ 

```typescript
// lib/notification-manager.ts
import { Client } from '@line/bot-sdk';
import { JSONDatabase } from './database';

export class NotificationManager {
  private client: Client;
  private db: JSONDatabase;

  constructor(lineClient: Client, database: JSONDatabase) {
    this.client = lineClient;
    this.db = database;
  }

  // å€‹äººé€šçŸ¥
  async sendPersonalNotification(userId: string, message: string): Promise<void> {
    try {
      await this.client.pushMessage(userId, {
        type: 'text',
        text: message
      });
    } catch (error) {
      console.error(`Failed to send notification to ${userId}:`, error);
    }
  }

  // ç®¡ç†è€…é€šçŸ¥
  async notifyAdmins(message: string): Promise<void> {
    const activeUsers = await this.db.getActiveUsers();
    const admins = activeUsers.filter(user => user.role === 'admin');

    const notifications = admins.map(admin => 
      this.sendPersonalNotification(admin.lineUserId, message)
    );

    await Promise.all(notifications);
  }

  // å…¨ã‚¹ã‚¿ãƒƒãƒ•é€šçŸ¥
  async notifyAllStaff(message: string): Promise<void> {
    const activeUsers = await this.db.getActiveUsers();

    const notifications = activeUsers.map(user => 
      this.sendPersonalNotification(user.lineUserId, message)
    );

    await Promise.all(notifications);
  }

  // ã‚·ãƒ•ãƒˆå¸Œæœ›æå‡ºé€šçŸ¥
  async notifyShiftRequestSubmitted(user: any, requestData: any): Promise<void> {
    const message = `ğŸ“ **æ–°ã—ã„ã‚·ãƒ•ãƒˆå¸Œæœ›**

ğŸ‘¤ **æå‡ºè€…**: ${user.displayName}ã•ã‚“
ğŸ“… **å¯¾è±¡æœˆ**: ${requestData.month}
ğŸ“ **å†…å®¹**: ${requestData.requestText}

ä»®ã‚·ãƒ•ãƒˆã«è‡ªå‹•åæ˜ ã•ã‚Œã¾ã—ãŸã€‚
ç¢ºèªã¯ã€Œ@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ä»®ã‚·ãƒ•ãƒˆè¦‹ã›ã¦ã€ã§è¡Œãˆã¾ã™ã€‚`;

    await this.notifyAdmins(message);
  }

  // ã‚·ãƒ•ãƒˆç¢ºå®šé€šçŸ¥
  async notifyShiftConfirmed(month: string): Promise<void> {
    const message = `ğŸ”’ **${month} ã‚·ãƒ•ãƒˆç¢ºå®šã®ãŠçŸ¥ã‚‰ã›**

ãŠç–²ã‚Œã•ã¾ã§ã™ï¼
${month}ã®ã‚·ãƒ•ãƒˆãŒç¢ºå®šã—ã¾ã—ãŸã€‚

ğŸ“± **ç¢ºèªæ–¹æ³•**:
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ æ¥æœˆã®ã‚·ãƒ•ãƒˆ

ğŸ“„ **PDFä¿å­˜**:
@ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆ ã‚·ãƒ•ãƒˆè¡¨ã®PDFæ¬²ã—ã„

å¤‰æ›´ãŒå¿…è¦ãªå ´åˆã¯ã€ãŠæ—©ã‚ã«ç®¡ç†è€…ã¾ã§ã”é€£çµ¡ãã ã•ã„ã€‚`;

    await this.notifyAllStaff(message);
  }

  // äººæ‰‹ä¸è¶³è­¦å‘Šé€šçŸ¥
  async notifyStaffShortage(shortageData: any): Promise<void> {
    const message = `âš ï¸ **äººæ‰‹ä¸è¶³è­¦å‘Š**

ä»¥ä¸‹ã®æ—¥æ™‚ã§äººæ‰‹ãŒä¸è¶³ã—ã¦ã„ã¾ã™ï¼š

${shortageData.map(item => 
  `ğŸ“… ${item.date} ${item.position}: ${item.shortage}åä¸è¶³`
).join('\n')}

å¯èƒ½ã§ã‚ã‚Œã°è¿½åŠ ã§ã‚·ãƒ•ãƒˆã«å…¥ã£ã¦ã„ãŸã ã‘ã‚‹æ–¹ã‚’å‹Ÿé›†ã—ã¦ã„ã¾ã™ã€‚
ã”å”åŠ›ã„ãŸã ã‘ã‚‹æ–¹ã¯ç®¡ç†è€…ã¾ã§ã”é€£çµ¡ãã ã•ã„ã€‚`;

    await this.notifyAllStaff(message);
  }

  // ä»£æ›¿ä¾é ¼é€šçŸ¥
  async notifySubstituteRequest(requestData: any): Promise<void> {
    const message = `ğŸ”„ **ã‚·ãƒ•ãƒˆä»£æ›¿ä¾é ¼**

ğŸ“… **å¯¾è±¡æ—¥**: ${requestData.targetDate}
ğŸ‘¤ **ä¾é ¼è€…**: ${requestData.requesterName}
ğŸ’­ **ç†ç”±**: ${requestData.reason}
ğŸ“ **è©³ç´°**: ${requestData.originalText}

ä»£æ›¿å¯èƒ½ãªæ–¹ã¯ç®¡ç†è€…ã¾ã§ã”é€£çµ¡ãã ã•ã„ã€‚`;

    await this.notifyAllStaff(message);
  }

  // ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹é€šçŸ¥
  async notifyMaintenance(maintenanceInfo: any): Promise<void> {
    const message = `ğŸ”§ **ã‚·ã‚¹ãƒ†ãƒ ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ã®ãŠçŸ¥ã‚‰ã›**

ğŸ“… **å®Ÿæ–½æ—¥æ™‚**: ${maintenanceInfo.startTime} ã€œ ${maintenanceInfo.endTime}
ğŸ“ **å†…å®¹**: ${maintenanceInfo.description}

ãƒ¡ãƒ³ãƒ†ãƒŠãƒ³ã‚¹ä¸­ã¯ã‚·ãƒ•ãƒˆãƒœãƒƒãƒˆãŒåˆ©ç”¨ã§ãã¾ã›ã‚“ã€‚
ç·Šæ€¥æ™‚ã¯ç›´æ¥ç®¡ç†è€…ã¾ã§ã”é€£çµ¡ãã ã•ã„ã€‚`;

    await this.notifyAllStaff(message);
  }

  // ã‚¨ãƒ©ãƒ¼é€šçŸ¥ï¼ˆç®¡ç†è€…ã®ã¿ï¼‰
  async notifySystemError(error: any): Promise<void> {
    const message = `ğŸš¨ **ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ç™ºç”Ÿ**

â° **ç™ºç”Ÿæ™‚åˆ»**: ${new Date().toLocaleString('ja-JP')}
ğŸ” **ã‚¨ãƒ©ãƒ¼å†…å®¹**: ${error.message}
ğŸ“ **ç™ºç”Ÿå ´æ‰€**: ${error.location || 'Unknown'}

ã‚·ã‚¹ãƒ†ãƒ ç®¡ç†è€…ã«ã‚ˆã‚‹å¯¾å¿œãŒå¿…è¦ã§ã™ã€‚`;

    await this.notifyAdmins(message);
  }

  // ãƒªãƒƒãƒãƒ¡ãƒƒã‚»ãƒ¼ã‚¸é€ä¿¡ï¼ˆãƒœã‚¿ãƒ³ä»˜ãï¼‰
  async sendRichMessage(userId: string, text: string, actions: any[]): Promise<void> {
    try {
      const message = {
        type: 'template',
        altText: text,
        template: {
          type: 'buttons',
          text: text,
          actions: actions
        }
      };

      await this.client.pushMessage(userId, message);
    } catch (error) {
      console.error(`Failed to send rich message to ${userId}:`, error);
      // ãƒ•ã‚©ãƒ¼ãƒ«ãƒãƒƒã‚¯ï¼šé€šå¸¸ã®ãƒ†ã‚­ã‚¹ãƒˆãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      await this.sendPersonalNotification(userId, text);
    }
  }

  // Flex Messageé€ä¿¡ï¼ˆã‚«ãƒ¼ãƒ‰å½¢å¼ï¼‰
  async sendFlexMessage(userId: string, flexData: any): Promise<void> {
    try {
      const message = {
        type: 'flex',
        altText: flexData.altText || 'ã‚·ãƒ•ãƒˆæƒ…å ±',
        contents: flexData
      };

      await this.client.pushMessage(userId, message);
    } catch (error) {
      console.error(`Failed to send flex message to ${userId}:`, error);
    }
  }
}
```

---

## ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ

### 1. èªè¨¼ãƒ»èªå¯ã‚·ã‚¹ãƒ†ãƒ 

```typescript
// lib/security.ts
import crypto from 'crypto';
import { NextApiRequest } from 'next';

// LINEç½²åæ¤œè¨¼
export function validateLineSignature(
  body: string,
  signature: string,
  channelSecret: string
): boolean {
  const hash = crypto
    .createHmac('SHA256', channelSecret)
    .update(body, 'utf8')
    .digest('base64');
  
  return hash === signature;
}

// APIã‚­ãƒ¼æ¤œè¨¼ï¼ˆå†…éƒ¨APIç”¨ï¼‰
export function validateApiKey(req: NextApiRequest): boolean {
  const apiKey = req.headers['x-api-key'];
  const validApiKey = process.env.INTERNAL_API_KEY;
  
  if (!apiKey || !validApiKey) {
    return false;
  }
  
  return crypto.timingSafeEqual(
    Buffer.from(apiKey as string),
    Buffer.from(validApiKey)
  );
}

// ãƒ¬ãƒ¼ãƒˆåˆ¶é™
const rateLimitStore = new Map<string, { count: number; resetTime: number }>();

export function checkRateLimit(
  identifier: string,
  maxRequests: number = 100,
  windowMs: number = 60000
): boolean {
  const now = Date.now();
  const limit = rateLimitStore.get(identifier);
  
  if (!limit || now > limit.resetTime) {
    rateLimitStore.set(identifier, {
      count: 1,
      resetTime: now + windowMs
    });
    return true;
  }
  
  if (limit.count >= maxRequests) {
    return false;
  }
  
  limit.count++;
  return true;
}

// å…¥åŠ›å€¤ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
export function sanitizeInput(input: string): string {
  return input
    .replace(/[<>]/g, '')  // HTMLã‚¿ã‚°é˜²æ­¢
    .replace(/['"]/g, '')  // ã‚¯ã‚©ãƒ¼ãƒˆé˜²æ­¢
    .trim()
    .slice(0, 1000);       // é•·ã•åˆ¶é™
}

// ãƒ¦ãƒ¼ã‚¶ãƒ¼æ¨©é™ãƒã‚§ãƒƒã‚¯
export async function checkUserPermission(
  lineUserId: string,
  requiredRole: 'admin' | 'staff'
): Promise<boolean> {
  try {
    const { db } = await import('./database');
    const user = await db.getUser(lineUserId);
    
    if (!user || !user.isActive) {
      return false;
    }
    
    if (requiredRole === 'admin') {
      return user.role === 'admin';
    }
    
    return user.role === 'admin' || user.role === 'staff';
  } catch (error) {
    console.error('Permission check error:', error);
    return false;
  }
}

// ã‚»ã‚­ãƒ¥ã‚¢ãªãƒ•ã‚¡ã‚¤ãƒ«ãƒ‘ã‚¹ç”Ÿæˆ
export function sanitizeFilePath(filename: string): string {
  return filename
    .replace(/[^a-zA-Z0-9._-]/g, '')  // å®‰å…¨ãªæ–‡å­—ã®ã¿
    .replace(/\.{2,}/g, '.')          // é€£ç¶šãƒ‰ãƒƒãƒˆé˜²æ­¢
    .slice(0, 100);                   // é•·ã•åˆ¶é™
}

// CSRFãƒˆãƒ¼ã‚¯ãƒ³ç”Ÿæˆï¼ˆå°†æ¥ã®æ‹¡å¼µç”¨ï¼‰
export function generateCSRFToken(): string {
  return crypto.randomBytes(32).toString('hex');
}

// ç§˜å¯†æƒ…å ±ã®ãƒã‚¹ã‚­ãƒ³ã‚°
export function maskSensitiveData(data: any): any {
  const masked = { ...data };
  
  const sensitiveFields = ['lineUserId', 'accessToken', 'channelSecret'];
  
  for (const field of sensitiveFields) {
    if (masked[field]) {
      const value = masked[field];
      masked[field] = value.slice(0, 4) + '*'.repeat(value.length - 8) + value.slice(-4);
    }
  }
  
  return masked;
}
```

### 2. ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°

```typescript
// lib/error-handler.ts
export class AppError extends Error {
  public statusCode: number;
  public code: string;
  public isOperational: boolean;

  constructor(
    message: string,
    statusCode: number = 500,
    code: string = 'INTERNAL_ERROR',
    isOperational: boolean = true
  ) {
    super(message);
    this.statusCode = statusCode;
    this.code = code;
    this.isOperational = isOperational;
    this.name = this.constructor.name;

    Error.captureStackTrace(this, this.constructor);
  }
}

// å®šç¾©æ¸ˆã¿ã‚¨ãƒ©ãƒ¼
export class ValidationError extends AppError {
  constructor(message: string, field?: string) {
    super(`Validation failed: ${message}`, 400, 'VALIDATION_ERROR');
    this.field = field;
  }
}

export class NotFoundError extends AppError {
  constructor(resource: string) {
    super(`${resource} not found`, 404, 'NOT_FOUND');
  }
}

export class PermissionError extends AppError {
  constructor(action: string) {
    super(`Permission denied for: ${action}`, 403, 'PERMISSION_DENIED');
  }
}

export class RateLimitError extends AppError {
  constructor() {
    super('Rate limit exceeded', 429, 'RATE_LIMIT_EXCEEDED');
  }
}

// ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
export function handleError(error: any, req?: any, res?: any): void {
  console.error('Error details:', {
    message: error.message,
    stack: error.stack,
    code: error.code,
    statusCode: error.statusCode,
    url: req?.url,
    method: req?.method,
    userId: req?.user?.lineUserId,
    timestamp: new Date().toISOString()
  });

  // æœ¬ç•ªç’°å¢ƒã§ã¯è©³ç´°ãªã‚¨ãƒ©ãƒ¼æƒ…å ±ã‚’éš ã™
  if (process.env.NODE_ENV === 'production' && res) {
    const isOperational = error.isOperational || false;
    
    if (!isOperational) {
      // ã‚·ã‚¹ãƒ†ãƒ ã‚¨ãƒ©ãƒ¼ã¯æ±ç”¨ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
      res.status(500).json({
        success: false,
        error: {
          code: 'INTERNAL_ERROR',
          message: 'An unexpected error occurred'
        }
      });
    } else {
      // é‹ç”¨ã‚¨ãƒ©ãƒ¼ã¯è©³ç´°ã‚’è¿”ã™
      res.status(error.statusCode || 500).json({
        success: false,
        error: {
          code: error.code,
          message: error.message
        }
      });
    }
  }
}

// éåŒæœŸã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼
export function asyncHandler(fn: Function) {
  return (req: any, res: any, next: any) => {
    Promise.resolve(fn(req, res, next)).catch(next);
  };
}

// ã‚°ãƒ­ãƒ¼ãƒãƒ«ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒ©ãƒ¼è¨­å®š
export function setupGlobalErrorHandlers(): void {
  process.on('uncaughtException', (error) => {
    console.error('Uncaught Exception:', error);
    process.exit(1);
  });

  process.on('unhandledRejection', (reason, promise) => {
    console.error('Unhandled Rejection at:', promise, 'reason:', reason);
    process.exit(1);
  });
}
```

---

## ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»é‹ç”¨

### 1. Vercelè¨­å®š

```json
// vercel.json
{
  "functions": {
    "pages/api/webhook.js": {
      "maxDuration": 10
    },
    "pages/api/pdf/[date].js": {
      "maxDuration": 30
    },
    "pages/api/shift/month/[month].js": {
      "maxDuration": 15
    }
  },
  "crons": [
    {
      "path": "/api/cron/daily-notification",
      "schedule": "0 20 * * *"
    },
    {
      "path": "/api/cron/submission-reminder", 
      "schedule": "0 20 25 * *"
    },
    {
      "path": "/api/cron/daily-backup",
      "schedule": "0 2 * * *"
    }
  ],
  "build": {
    "env": {
      "PUPPETEER_SKIP_CHROMIUM_DOWNLOAD": "true"
    }
  },
  "regions": ["nrt1"],
  "framework": "nextjs"
}
```

### 2. ç’°å¢ƒå¤‰æ•°è¨­å®š

```bash
# .env.local (é–‹ç™ºç’°å¢ƒ)
LINE_CHANNEL_SECRET=your_line_channel_secret
LINE_CHANNEL_ACCESS_TOKEN=your_line_access_token
INTERNAL_API_KEY=your_internal_api_key_for_cron_jobs
PUPPETEER_EXECUTABLE_PATH=/usr/bin/google-chrome-stable

# .env.production (æœ¬ç•ªç’°å¢ƒ)
NODE_ENV=production
LINE_CHANNEL_SECRET=prod_line_channel_secret
LINE_CHANNEL_ACCESS_TOKEN=prod_line_access_token
INTERNAL_API_KEY=prod_internal_api_key
NEXT_PUBLIC_BASE_URL=https://your-app.vercel.app
```

### 3. ãƒ‘ãƒƒã‚±ãƒ¼ã‚¸.json

```json
{
  "name": "line-bot-shift-backend",
  "version": "1.0.0",
  "private": true,
  "scripts": {
    "dev": "next dev",
    "build": "next build",
    "start": "next start",
    "lint": "next lint",
    "type-check": "tsc --noEmit",
    "test": "jest",
    "test:watch": "jest --watch",
    "backup": "node scripts/backup.js",
    "restore": "node scripts/restore.js"
  },
  "dependencies": {
    "next": "^14.0.0",
    "react": "^18.2.0",
    "react-dom": "^18.2.0",
    "@line/bot-sdk": "^7.5.2",
    "puppeteer": "^21.5.0",
    "node-cron": "^3.0.2",
    "qrcode": "^1.5.3"
  },
  "devDependencies": {
    "@types/node": "^20.8.0",
    "@types/react": "^18.2.0",
    "@types/node-cron": "^3.0.8",
    "@types/qrcode": "^1.5.0",
    "typescript": "^5.2.0",
    "jest": "^29.7.0",
    "@types/jest": "^29.5.5",
    "eslint": "^8.51.0",
    "eslint-config-next": "^14.0.0"
  }
}
```

### 4. é‹ç”¨ã‚¹ã‚¯ãƒªãƒ—ãƒˆ

```typescript
// scripts/backup.ts
import { db } from '../lib/database';
import path from 'path';
import fs from 'fs/promises';

async function performBackup() {
  try {
    console.log('Starting manual backup...');
    
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹èª­ã¿è¾¼ã¿
    await db.load();
    
    // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ•ã‚¡ã‚¤ãƒ«ä½œæˆ
    const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
    const backupPath = path.join(process.cwd(), `backups/manual_backup_${timestamp}.json`);
    
    await fs.mkdir(path.dirname(backupPath), { recursive: true });
    await fs.writeFile(backupPath, JSON.stringify(db.data, null, 2));
    
    console.log(`Backup completed: ${backupPath}`);
    
    // çµ±è¨ˆæƒ…å ±è¡¨ç¤º
    const stats = {
      users: Object.keys(db.data.users).length,
      shifts: Object.values(db.data.shifts).flat().length,
      notices: db.data.sharedNotices.filter(n => n.isActive).length
    };
    
    console.log('Backup statistics:', stats);
    
  } catch (error) {
    console.error('Backup failed:', error);
    process.exit(1);
  }
}

// ã‚¹ã‚¯ãƒªãƒ—ãƒˆå®Ÿè¡Œ
if (require.main === module) {
  performBackup();
}
```

### 5. ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯API

```typescript
// pages/api/health.ts
import { NextApiRequest, NextApiResponse } from 'next';
import { db } from '../../lib/database';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'GET') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ¥ç¶šç¢ºèª
    await db.load();
    
    // åŸºæœ¬çµ±è¨ˆå–å¾—
    const stats = await db.getStatistics();
    
    // ã‚·ã‚¹ãƒ†ãƒ æƒ…å ±
    const systemInfo = {
      timestamp: new Date().toISOString(),
      uptime: process.uptime(),
      memory: process.memoryUsage(),
      version: process.env.npm_package_version || '1.0.0',
      nodeVersion: process.version
    };

    // ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯çµæœ
    const healthCheck = {
      status: 'healthy',
      database: 'connected',
      statistics: stats,
      system: systemInfo
    };

    res.status(200).json(healthCheck);
    
  } catch (error) {
    console.error('Health check failed:', error);
    
    res.status(503).json({
      status: 'unhealthy',
      error: error.message,
      timestamp: new Date().toISOString()
    });
  }
}
```

### 6. ç›£è¦–ãƒ»ã‚¢ãƒ©ãƒ¼ãƒˆè¨­å®š

```typescript
// lib/monitoring.ts
export class MonitoringManager {
  // ãƒ¡ãƒˆãƒªã‚¯ã‚¹åé›†
  static collectMetrics() {
    return {
      memory: process.memoryUsage(),
      uptime: process.uptime(),
      timestamp: Date.now()
    };
  }

  // ãƒ‘ãƒ•ã‚©ãƒ¼ãƒãƒ³ã‚¹ç›£è¦–
  static async measureApiPerformance(apiName: string, operation: () => Promise<any>) {
    const start = Date.now();
    
    try {
      const result = await operation();
      const duration = Date.now() - start;
      
      // é…ã„APIã®è­¦å‘Š
      if (duration > 3000) {
        console.warn(`Slow API detected: ${apiName} took ${duration}ms`);
      }
      
      return result;
    } catch (error) {
      const duration = Date.now() - start;
      console.error(`API failed: ${apiName} after ${duration}ms`, error);
      throw error;
    }
  }

  // ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
  static async checkDataIntegrity(): Promise<{ isHealthy: boolean; issues: string[] }> {
    const issues: string[] = [];
    
    try {
      await db.load();
      
      // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§
      for (const [userId, user] of Object.entries(db.data.users)) {
        if (!user.lineUserId) {
          issues.push(`User ${userId} missing lineUserId`);
        }
        if (!user.joinedAt) {
          issues.push(`User ${userId} missing joinedAt`);
        }
      }
      
      // ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§
      for (const [date, shifts] of Object.entries(db.data.shifts)) {
        for (const shift of shifts) {
          if (!shift.userId || !shift.positionId) {
            issues.push(`Shift ${shift.id} missing required fields`);
          }
        }
      }
      
      return {
        isHealthy: issues.length === 0,
        issues
      };
      
    } catch (error) {
      issues.push(`Database integrity check failed: ${error.message}`);
      return { isHealthy: false, issues };
    }
  }
}
```

---

## ç·åˆã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£ã¾ã¨ã‚

### ã‚·ã‚¹ãƒ†ãƒ ç‰¹å¾´

1. **è»½é‡ãƒ»ä¿å®ˆæ€§é‡è¦–**
   - JSONãƒ™ãƒ¼ã‚¹ã®ãƒ‡ãƒ¼ã‚¿ã‚¹ãƒˆãƒ¬ãƒ¼ã‚¸
   - ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹å¯¾å¿œè¨­è¨ˆ
   - æœ€å°é™ã®ä¾å­˜é–¢ä¿‚

2. **LINEä¸­å¿ƒã®é‹ç”¨**
   - Webhooké§†å‹•ã®ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£
   - è‡ªç„¶è¨€èªå‡¦ç†ï¼ˆç°¡æ˜“ç‰ˆï¼‰
   - ãƒªã‚¢ãƒ«ã‚¿ã‚¤ãƒ é€šçŸ¥ã‚·ã‚¹ãƒ†ãƒ 

3. **ã‚¹ã‚±ãƒ¼ãƒ©ãƒ“ãƒªãƒ†ã‚£**
   - ãƒ•ã‚¡ã‚¤ãƒ«ãƒ™ãƒ¼ã‚¹â†’PostgreSQLç§»è¡Œæº–å‚™
   - ãƒ¬ãƒ¼ãƒˆåˆ¶é™ãƒ»ã‚¨ãƒ©ãƒ¼ãƒãƒ³ãƒ‰ãƒªãƒ³ã‚°
   - è‡ªå‹•ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ãƒ»ã‚¢ãƒ¼ã‚«ã‚¤ãƒ–

4. **ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£**
   - LINEç½²åæ¤œè¨¼
   - å…¥åŠ›å€¤ã‚µãƒ‹ã‚¿ã‚¤ã‚¼ãƒ¼ã‚·ãƒ§ãƒ³
   - æ¨©é™ãƒ™ãƒ¼ã‚¹ã‚¢ã‚¯ã‚»ã‚¹åˆ¶å¾¡

5. **é‹ç”¨ãƒ»ç›£è¦–**
   - ãƒ˜ãƒ«ã‚¹ãƒã‚§ãƒƒã‚¯API
   - è‡ªå‹•åŒ–ã•ã‚ŒãŸã‚¸ãƒ§ãƒ–ç®¡ç†
   - ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯

ã“ã®è¨­è¨ˆã«ã‚ˆã‚Šã€å°è¦æ¨¡ãƒãƒ¼ãƒ å‘ã‘ã®ä¿å®ˆã—ã‚„ã™ã„ã‚·ãƒ•ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ ã‚’å®Ÿç¾ã§ãã¾ã™ã€‚JSONãƒ™ãƒ¼ã‚¹ã‹ã‚‰å§‹ã‚ã¦ã€å¿…è¦ã«å¿œã˜ã¦PostgreSQLã«ç§»è¡Œå¯èƒ½ãªæŸ”è»Ÿæ€§ã‚‚ç¢ºä¿ã—ã¦ã„ã¾ã™ã€‚# LINE Bot ã‚·ãƒ•ãƒˆç®¡ç†ã‚·ã‚¹ãƒ†ãƒ  ãƒãƒƒã‚¯ã‚¨ãƒ³ãƒ‰è¨­è¨ˆæ›¸

## ç›®æ¬¡
1. [ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦](#ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦)
2. [APIè¨­è¨ˆ](#apiè¨­è¨ˆ)
3. [ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ](#ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ)
4. [LINE Botå‡¦ç†](#line-botå‡¦ç†)
5. [ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†](#ãƒãƒƒã‚¯ã‚°ãƒ©ã‚¦ãƒ³ãƒ‰å‡¦ç†)
6. [ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ](#ã‚»ã‚­ãƒ¥ãƒªãƒ†ã‚£è¨­è¨ˆ)
7. [ãƒ‡ãƒ—ãƒ­ã‚¤ãƒ»é‹ç”¨](#ãƒ‡ãƒ—ãƒ­ã‚¤é‹ç”¨)

---

## ã‚¢ãƒ¼ã‚­ãƒ†ã‚¯ãƒãƒ£æ¦‚è¦

### ã‚·ã‚¹ãƒ†ãƒ æ§‹æˆ
```
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚              Frontend (Next.js)        â”‚
â”‚         â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â” â”‚
â”‚         â”‚     è¡¨ç¤ºå°‚ç”¨Webç”»é¢          â”‚ â”‚
â”‚         â”‚  - ã‚·ãƒ•ãƒˆè¡¨è¡¨ç¤º             â”‚ â”‚
â”‚         â”‚  - PDF/ç”»åƒå‡ºåŠ›             â”‚ â”‚
â”‚         â”‚  - å…±æœ‰äº‹é …è¡¨ç¤º             â”‚ â”‚
â”‚         â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜ â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ HTTP/REST API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚           Backend (Node.js/Express)    â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ API Routes  â”‚  â”‚ LINE Bot Engine â”‚   â”‚
â”‚  â”‚             â”‚  â”‚                 â”‚   â”‚
â”‚  â”‚ /api/shift  â”‚  â”‚ - Webhook       â”‚   â”‚
â”‚  â”‚ /api/pdf    â”‚  â”‚ - NLP Parser    â”‚   â”‚
â”‚  â”‚ /api/image  â”‚  â”‚ - State Manager â”‚   â”‚
â”‚  â”‚ /api/notice â”‚  â”‚ - Notification  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â”‚         â”‚                   â”‚           â”‚
â”‚  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”  â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”   â”‚
â”‚  â”‚ File System â”‚  â”‚ Scheduled Jobs  â”‚   â”‚
â”‚  â”‚             â”‚  â”‚                 â”‚   â”‚
â”‚  â”‚ JSON DB     â”‚  â”‚ - Daily Notify  â”‚   â”‚
â”‚  â”‚ File Cache  â”‚  â”‚ - Auto Backup   â”‚   â”‚
â”‚  â”‚ PDF/Images  â”‚  â”‚ - Data Archive  â”‚   â”‚
â”‚  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜  â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜   â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”¬â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
                  â”‚ LINE Messaging API
â”Œâ”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”´â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”
â”‚            LINE Platform                â”‚
â”‚  - Webhook Events                       â”‚
â”‚  - Message Sending                      â”‚
â”‚  - User Management                      â”‚
â””â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”€â”˜
```

### æŠ€è¡“ã‚¹ã‚¿ãƒƒã‚¯
- **Runtime**: Node.js 18+
- **Framework**: Express.js
- **Database**: JSON Files (è»½é‡ãƒ»ä¿å®ˆæ€§é‡è¦–)
- **External API**: LINE Messaging API
- **PDFç”Ÿæˆ**: Puppeteer
- **Scheduling**: node-cron
- **Deployment**: Vercel (ã‚µãƒ¼ãƒãƒ¼ãƒ¬ã‚¹)

---

## APIè¨­è¨ˆ

### 1. RESTful API ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ

```typescript
// types/api.ts
export interface APIResponse<T = any> {
  success: boolean;
  data?: T;
  error?: {
    code: string;
    message: string;
    details?: any;
  };
  meta?: {
    timestamp: string;
    version: string;
  };
}

export interface PaginationParams {
  page?: number;
  limit?: number;
  sortBy?: string;
  sortOrder?: 'asc' | 'desc';
}

export interface DateRangeParams {
  startDate?: string;
  endDate?: string;
}
```

#### ã‚·ãƒ•ãƒˆé–¢é€£API
```typescript
// pages/api/shift/[date].ts
/*
GET /api/shift/[date]
- æŒ‡å®šæ—¥ã®ã‚·ãƒ•ãƒˆæƒ…å ±å–å¾—
- ãƒ¬ã‚¹ãƒãƒ³ã‚¹: 
  - shifts: EnrichedShift[]
  - positions: Position[]
  - users: User[]
  - notices: Notice[]
  - dailyMessages: DailyMessage[]
*/

import { NextApiRequest, NextApiResponse } from 'next';
import { db } from '../../../lib/database';
import { validateDate, enrichShifts } from '../../../lib/utils';
import { APIResponse } from '../../../types/api';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>
) {
  try {
    const { date } = req.query;
    
    // ãƒãƒªãƒ‡ãƒ¼ã‚·ãƒ§ãƒ³
    if (!validateDate(date as string)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_DATE',
          message: 'Invalid date format. Expected YYYY-MM-DD'
        }
      });
    }

    if (req.method === 'GET') {
      return await handleGetShift(req, res, date as string);
    }

    res.status(405).json({
      success: false,
      error: {
        code: 'METHOD_NOT_ALLOWED',
        message: `Method ${req.method} not allowed`
      }
    });
  } catch (error) {
    console.error('Shift API Error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Internal server error'
      }
    });
  }
}

async function handleGetShift(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>,
  date: string
) {
  // ä¸¦åˆ—ãƒ‡ãƒ¼ã‚¿å–å¾—
  const [shifts, notices, positions, users] = await Promise.all([
    db.getShifts(date),
    db.getActiveNotices(),
    db.getPositions(),
    db.getActiveUsers()
  ]);

  // å½“æ—¥ã®å ´åˆã¯æ—¥æ¬¡ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸ã‚‚å–å¾—
  const today = new Date().toISOString().split('T')[0];
  const dailyMessages = date === today ? await db.getDailyMessages(date) : [];

  // ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿ã®çµåˆãƒ»æ‹¡å¼µ
  const enrichedShifts = enrichShifts(shifts, users, positions);

  res.status(200).json({
    success: true,
    data: {
      date,
      shifts: enrichedShifts,
      notices,
      positions,
      users,
      dailyMessages,
      isToday: date === today
    },
    meta: {
      timestamp: new Date().toISOString(),
      version: '1.0.0'
    }
  });
}
```

#### æœˆé–“ã‚·ãƒ•ãƒˆAPI
```typescript
// pages/api/shift/month/[month].ts
/*
GET /api/shift/month/[month]
- æœˆé–“ã‚·ãƒ•ãƒˆæƒ…å ±å–å¾—
- ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:
  - userId?: string (ç‰¹å®šãƒ¦ãƒ¼ã‚¶ãƒ¼ã®ã¿)
  - positionId?: string (ç‰¹å®šãƒã‚¸ã‚·ãƒ§ãƒ³ã®ã¿)
  - status?: 'draft' | 'confirmed' (ã‚¹ãƒ†ãƒ¼ã‚¿ã‚¹çµã‚Šè¾¼ã¿)
*/

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>
) {
  try {
    const { month } = req.query;
    const { userId, positionId, status } = req.query;

    if (!validateMonth(month as string)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_MONTH',
          message: 'Invalid month format. Expected YYYY-MM'
        }
      });
    }

    if (req.method === 'GET') {
      return await handleGetMonthlyShifts(req, res, {
        month: month as string,
        userId: userId as string,
        positionId: positionId as string,
        status: status as string
      });
    }

    res.status(405).json({
      success: false,
      error: {
        code: 'METHOD_NOT_ALLOWED',
        message: `Method ${req.method} not allowed`
      }
    });
  } catch (error) {
    console.error('Monthly Shift API Error:', error);
    res.status(500).json({
      success: false,
      error: {
        code: 'INTERNAL_SERVER_ERROR',
        message: 'Internal server error'
      }
    });
  }
}

async function handleGetMonthlyShifts(
  req: NextApiRequest,
  res: NextApiResponse<APIResponse>,
  filters: {
    month: string;
    userId?: string;
    positionId?: string;
    status?: string;
  }
) {
  const monthlyShifts = await db.getMonthlyShifts(filters.month);
  
  // ãƒ•ã‚£ãƒ«ã‚¿ãƒªãƒ³ã‚°
  let filteredShifts = monthlyShifts;
  
  if (filters.userId) {
    filteredShifts = filteredShifts.filter(shift => shift.userId === filters.userId);
  }
  
  if (filters.positionId) {
    filteredShifts = filteredShifts.filter(shift => shift.positionId === filters.positionId);
  }
  
  if (filters.status) {
    filteredShifts = filteredShifts.filter(shift => shift.status === filters.status);
  }

  // çµ±è¨ˆæƒ…å ±è¨ˆç®—
  const statistics = calculateMonthlyStatistics(filteredShifts);

  res.status(200).json({
    success: true,
    data: {
      month: filters.month,
      shifts: filteredShifts,
      statistics,
      filters
    }
  });
}
```

#### PDF/ç”»åƒå‡ºåŠ›API
```typescript
// pages/api/pdf/[date].ts
/*
GET /api/pdf/[date]
- ã‚·ãƒ•ãƒˆè¡¨PDFç”Ÿæˆãƒ»å‡ºåŠ›
- ã‚¯ã‚¨ãƒªãƒ‘ãƒ©ãƒ¡ãƒ¼ã‚¿:
  - format?: 'A4' | 'A3' | 'Letter'
  - orientation?: 'portrait' | 'landscape'
  - includeNotices?: boolean
*/

import puppeteer from 'puppeteer';
import { generateShiftHTML } from '../../../lib/pdf-generator';

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  try {
    const { date } = req.query;
    const { 
      format = 'A4', 
      orientation = 'portrait',
      includeNotices = 'true'
    } = req.query;

    if (!validateDate(date as string)) {
      return res.status(400).json({
        success: false,
        error: {
          code: 'INVALID_DATE',
          message: 'Invalid date format'
        }
      });
    }

    if (req.method === 'GET') {
      return await generatePDF(req, res, {
        date: date as string,
        format: format as string,
        orientation: orientation as 'portrait' | 'landscape',
        includeNotices: includeNotices === 'true'
      });
    }

    res.status(405).json({
      success: false,
      error: { code: 'METHOD_NOT_ALLOWED', message: 'Method not allowed' }
    });
  } catch (error) {
    console.error('PDF Generation Error:', error);
    res.status(500).json({
      success: false,
      error: { code: 'PDF_GENERATION_FAILED', message: 'PDF generation failed' }
    });
  }
}

async function generatePDF(
  req: NextApiRequest,
  res: NextApiResponse,
  options: {
    date: string;
    format: string;
    orientation: 'portrait' | 'landscape';
    includeNotices: boolean;
  }
) {
  const browser = await puppeteer.launch({
    headless: 'new',
    args: ['--no-sandbox', '--disable-setuid-sandbox']
  });

  try {
    const page = await browser.newPage();
    
    // ã‚·ãƒ•ãƒˆãƒ‡ãƒ¼ã‚¿å–å¾—
    const shiftData = await getShiftDataForPDF(options.date, options.includeNotices);
    
    // HTMLç”Ÿæˆ
    const html = generateShiftHTML(shiftData, options);
    
    await page.setContent(html, { waitUntil: 'networkidle0' });
    
    // PDFç”Ÿæˆã‚ªãƒ—ã‚·ãƒ§ãƒ³
    const pdfOptions = {
      format: options.format as any,
      orientation: options.orientation,
      margin: {
        top: '20mm',
        right: '15mm',
        bottom: '20mm',
        left: '15mm'
      },
      printBackground: true,
      displayHeaderFooter: true,
      headerTemplate: generatePDFHeader(options.date),
      footerTemplate: generatePDFFooter()
    };

    const pdf = await page.pdf(pdfOptions);

    // ãƒ¬ã‚¹ãƒãƒ³ã‚¹ãƒ˜ãƒƒãƒ€ãƒ¼è¨­å®š
    res.setHeader('Content-Type', 'application/pdf');
    res.setHeader('Content-Disposition', `attachment; filename="shift_${options.date}.pdf"`);
    res.setHeader('Cache-Control', 'public, max-age=3600'); // 1æ™‚é–“ã‚­ãƒ£ãƒƒã‚·ãƒ¥
    
    res.send(pdf);
  } finally {
    await browser.close();
  }
}
```

### 2. LINE Bot Webhook API

```typescript
// pages/api/webhook.ts
/*
POST /api/webhook
- LINE Webhook ã‚¨ãƒ³ãƒ‰ãƒã‚¤ãƒ³ãƒˆ
- LINEç½²åæ¤œè¨¼
- ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸è§£æãƒ»ãƒ¬ã‚¹ãƒãƒ³ã‚¹å‡¦ç†
*/

import { NextApiRequest, NextApiResponse } from 'next';
import { Client, middleware, MiddlewareConfig } from '@line/bot-sdk';
import { LineMentionHandler } from '../../lib/line-mention-handler';
import { validateLineSignature } from '../../lib/security';

const config: MiddlewareConfig = {
  channelAccessToken: process.env.LINE_CHANNEL_ACCESS_TOKEN!,
  channelSecret: process.env.LINE_CHANNEL_SECRET!,
};

const client = new Client(config);
const mentionHandler = new LineMentionHandler(client);

export default async function handler(
  req: NextApiRequest,
  res: NextApiResponse
) {
  if (req.method !== 'POST') {
    return res.status(405).json({ error: 'Method not allowed' });
  }

  try {
    // LINEç½²åæ¤œè¨¼
    const signature = req.headers['x-line-signature'] as string;
    const body = JSON.stringify(req.body);
    
    if (!validateLineSignature(body, signature, config.channelSecret)) {
      console.error('Invalid LINE signature');
      return res.status(401).json({ error: 'Invalid signature' });
    }

    // Webhook ã‚¤ãƒ™ãƒ³ãƒˆå‡¦ç†
    const events = req.body.events;
    
    await Promise.all(events.map(async (event: any) => {
      try {
        await handleLineEvent(event);
      } catch (error) {
        console.error('Event handling error:', error);
        // å€‹åˆ¥ã‚¤ãƒ™ãƒ³ãƒˆã‚¨ãƒ©ãƒ¼ã¯ãƒ­ã‚°ã®ã¿ï¼ˆå…¨ä½“ã¯ç¶™ç¶šï¼‰
      }
    }));

    res.status(200).json({ success: true });
  } catch (error) {
    console.error('Webhook error:', error);
    res.status(500).json({ error: 'Internal server error' });
  }
}

async function handleLineEvent(event: any) {
  console.log('LINE Event:', JSON.stringify(event, null, 2));

  switch (event.type) {
    case 'message':
      if (event.message.type === 'text') {
        await mentionHandler.handleMessage(event);
      }
      break;
      
    case 'memberJoined':
      await handleMemberJoined(event);
      break;
      
    case 'memberLeft':
      await handleMemberLeft(event);
      break;
      
    case 'follow':
      await handleFollow(event);
      break;
      
    case 'unfollow':
      await handleUnfollow(event);
      break;
      
    default:
      console.log('Unhandled event type:', event.type);
  }
}

async function handleMemberJoined(event: any) {
  // æ–°ãƒ¡ãƒ³ãƒãƒ¼è‡ªå‹•ç™»éŒ²
  for (const member of event.joined.members) {
    if (member.type === 'user') {
      try {
        const profile = await client.getProfile(member.userId);
        
        await db.saveUser(member.userId, {
          displayName: profile.displayName,
          role: 'staff',
          isActive: true,
          joinedAt: new Date().toISOString()
        });
        
        // ã‚¦ã‚§ãƒ«ã‚«ãƒ ãƒ¡ãƒƒã‚»ãƒ¼ã‚¸
        const welcomeMessage = generateWelcomeMessage(profile.displayName);
        await client.pushMessage(member.userId, {
          type: 'text',
          text: welcomeMessage
        });
        
        console.log(`New user registered: ${profile.displayName} (${member.userId})`);
      } catch (error) {
        console.error('Failed to handle member joined:', error);
      }
    }
  }
}

async function handleMemberLeft(event: any) {
  // ãƒ¡ãƒ³ãƒãƒ¼é€€å‡ºå‡¦ç†
  for (const member of event.left.members) {
    if (member.type === 'user') {
      await db.deactivateUser(member.userId);
      console.log(`User deactivated: ${member.userId}`);
    }
  }
}
```

---

## ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹è¨­è¨ˆ

### 1. JSON Database å®Ÿè£…

```typescript
// lib/database.ts
import fs from 'fs/promises';
import path from 'path';
import { DatabaseSchema, User, Shift, Notice, DailyMessage } from '../types/database';

export class JSONDatabase {
  private data: DatabaseSchema | null = null;
  private lastModified: Date | null = null;
  private readonly dbPath: string;
  private readonly backupDir: string;
  private isLoading = false;

  constructor() {
    this.dbPath = path.join(process.cwd(), 'data/database.json');
    this.backupDir = path.join(process.cwd(), 'data/backups');
  }

  // ãƒ‡ãƒ¼ã‚¿èª­ã¿è¾¼ã¿ï¼ˆæ’ä»–åˆ¶å¾¡ä»˜ãï¼‰
  async load(): Promise<void> {
    if (this.isLoading) {
      // åŒæ™‚èª­ã¿è¾¼ã¿é˜²æ­¢
      await new Promise(resolve => setTimeout(resolve, 100));
      return this.load();
    }

    this.isLoading = true;
    
    try {
      const stats = await fs.stat(this.dbPath);
      
      if (!this.data || stats.mtime > this.lastModified) {
        const content = await fs.readFile(this.dbPath, 'utf8');
        this.data = JSON.parse(content);
        this.lastModified = stats.mtime;
        
        // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
        this.validateDataIntegrity();
      }
    } catch (error) {
      if (error.code === 'ENOENT') {
        console.log('Database file not found, creating initial data...');
        this.data = this.getInitialData();
        await this.save();
      } else {
        console.error('Database load error:', error);
        throw new Error('Failed to load database');
      }
    } finally {
      this.isLoading = false;
    }
  }

  // ãƒ‡ãƒ¼ã‚¿ä¿å­˜ï¼ˆãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä»˜ãï¼‰
  async save(): Promise<void> {
    if (!this.data) {
      throw new Error('No data to save');
    }

    try {
      // ãƒ¡ã‚¿ãƒ‡ãƒ¼ã‚¿æ›´æ–°
      this.data.metadata.lastUpdatedAt = new Date().toISOString();
      this.data.metadata.version = '1.0.0';

      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
      await this.createBackup();

      // ãƒ¡ã‚¤ãƒ³ãƒ•ã‚¡ã‚¤ãƒ«ä¿å­˜
      const tempPath = `${this.dbPath}.tmp`;
      await fs.writeFile(tempPath, JSON.stringify(this.data, null, 2));
      await fs.rename(tempPath, this.dbPath);
      
      this.lastModified = new Date();
      
      console.log('Database saved successfully');
    } catch (error) {
      console.error('Database save error:', error);
      throw new Error('Failed to save database');
    }
  }

  // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—ä½œæˆ
  private async createBackup(): Promise<void> {
    try {
      await fs.mkdir(this.backupDir, { recursive: true });
      
      const timestamp = new Date().toISOString().replace(/[:.]/g, '-');
      const backupPath = path.join(this.backupDir, `backup_${timestamp}.json`);
      
      await fs.writeFile(backupPath, JSON.stringify(this.data, null, 2));
      
      // å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‰Šé™¤ï¼ˆ30æ—¥ä»¥ä¸Šï¼‰
      await this.cleanupOldBackups();
    } catch (error) {
      console.error('Backup creation failed:', error);
      // ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å¤±æ•—ã¯è­¦å‘Šãƒ¬ãƒ™ãƒ«ï¼ˆãƒ¡ã‚¤ãƒ³å‡¦ç†ã¯ç¶™ç¶šï¼‰
    }
  }

  // å¤ã„ãƒãƒƒã‚¯ã‚¢ãƒƒãƒ—å‰Šé™¤
  private async cleanupOldBackups(): Promise<void> {
    try {
      const files = await fs.readdir(this.backupDir);
      const thirtyDaysAgo = new Date();
      thirtyDaysAgo.setDate(thirtyDaysAgo.getDate() - 30);

      for (const file of files) {
        if (file.startsWith('backup_') && file.endsWith('.json')) {
          const filePath = path.join(this.backupDir, file);
          const stats = await fs.stat(filePath);
          
          if (stats.mtime < thirtyDaysAgo) {
            await fs.unlink(filePath);
            console.log(`Deleted old backup: ${file}`);
          }
        }
      }
    } catch (error) {
      console.error('Backup cleanup failed:', error);
    }
  }

  // ãƒ‡ãƒ¼ã‚¿æ•´åˆæ€§ãƒã‚§ãƒƒã‚¯
  private validateDataIntegrity(): void {
    if (!this.data) return;

    // å¿…é ˆãƒ•ã‚£ãƒ¼ãƒ«ãƒ‰ãƒã‚§ãƒƒã‚¯
    const requiredKeys = ['users', 'positions', 'shifts', 'shiftRequests', 'sharedNotices', 'settings', 'metadata'];
    for (const key of requiredKeys) {
      if (!(key in this.data)) {
        console.warn(`Missing required field: ${key}`);
        this.data[key] = this.getDefaultValueForKey(key);
      }
    }

    // ãƒ¦ãƒ¼ã‚¶ãƒ¼ãƒ‡ãƒ¼ã‚¿ã®ä¿®å¾©
    for (const [userId, user] of Object.entries(this.data.users)) {
      if (!user.lineUserId) {
        user.lineUserId = userId;
      }
      if (!user.joinedAt) {
        user.joinedAt = new Date().toISOString();
      }
    }

    console.log('Data integrity check completed');
  }

  // === åŸºæœ¬CRUDæ“ä½œ ===

  // ãƒ¦ãƒ¼ã‚¶ãƒ¼æ“ä½œ
  async getUser(lineUserId: string): Promise<User | null> {
    await this.load();
    return this.data.users[lineUserId] || null;
  }

  async saveUser(lineUserId: string, userData: Partial<User>): Promise<User> {
    await this.load();
    
    const isNewUser = !this.data.users[lineUserId];
    
    this.data.users[lineUserId] = {
      lineUserId,
      displayName: '',
      role: 'staff',
      isActive: true,
      joinedAt: new Date().toISOString(),
      lastSeenAt: new Date().toISOString(),
      ...this.data.users[lineUserId],
      ...userData
    };

    if (isNewUser) {
      this.data.metadata.totalUsers += 1;
    }

    await this.save();
    return this.data.users[lineUserId];
  }

  async getActiveUsers(): Promise<User[]> {
    await this.load();
    return Object.values(this.data.users).filter(user => user.isActive);
  }

  async deactivateUser(lineUserId: string): Promise<void> {
    await this.load();
    
    if (this.data.users[lineUserId]) {
      this.data.users[lineUserId].isActive = false;
      this.data.users[lineUserId].leftAt = new Date().toISOString();
      await this.save();
    }
  }

  // ã‚·ãƒ•ãƒˆæ“ä½œ
  async getShifts(date: string): Promise<Shift[]> {
    await this.load();
    return this.data.shifts[date] || [];
  }

  async getMonthlyShifts(month: string): Promise<Shift[]> {
    await this.load();
    
    const monthlyShifts: Shift[] = [];
    
    // è©²å½“æœˆã®ã™ã¹ã¦ã®æ—¥ä»˜ã‚’ãƒã‚§ãƒƒã‚¯
    for (const [date, shifts] of Object.entries(this.data.shifts)) {
      if (date.startsWith(month)) {
        monthlyShifts.push(...shifts);
      }
    }
    
    return monthlyShifts;
  }

  async saveShift(date: string, shiftData: Omit<Shift, 'id' | 'createdAt'>): Promise<Shift> {
    await this.load();
    
    if (!this.data.shifts[date]) {
      this.data.shifts[date] = [];
    }

    const shift: Shift = {
      id: this.generateId('shift'),
      ...shiftData,
      createdAt: new Date().toISOString()
    };

    this.data.shifts[date].push(shift);
    this.data.metadata.totalShifts += 1;
    
    await this.save();
    return shift;
  }

  async updateShift(date: string, shiftId: string, updateData: Partial<Shift>): Promise<Shift | null> {
    await this.load();
    
    const shifts = this.data.shifts[date] || [];
    const shiftIndex = shifts.findIndex(s => s.id === shiftId);
    
    if (shiftIndex !== -1) {
      this.data.shifts[date][shiftIndex] = {
        ...this.data.shifts[date][shiftIndex],
        ...updateData,
        updatedAt: new Date().toISOString()
      };
      
      await this.save();
      return this.data.shifts[date][shiftIndex];
    }
    
    return null;
  }

  async deleteShift(date: string, shiftId: string): Promise<boolean> {
    await this.load();
    
    const shifts = this.data.shifts[date] || [];
    const initialLength = shifts.length;
    
    this.data.shifts[date] = shifts.filter(s => s.id !== shiftId);
    
    if (this.data.shifts[date].length < initialLength) {
      await this.save();
      return true;
    }
    
    return false;
  }

  // å…±æœ‰äº‹é …æ“ä½œ
  async getActiveNotices(): Promise<Notice[]> {
    await this.load();
    
    const today = new Date().toISOString().split('T')[0];
    
    return this.data.sharedNotices.filter(notice => 
      notice.isActive && 
      notice.startDate <= today && 
      (!notice.endDate || notice.endDate >= today)
    );
  }

  async saveNotice(noticeData: Omit<Notice, 'id' | 'createdAt'>): Promise<Notice> {
    await this.load();

    const notice: Notice = {
      id: this.generateId('notice'),
      ...noticeData,
      isActive: true,
      createdAt: new Date().toISOString()
    };

    this.data.sharedNotices.push(notice);
    await this.save();
    
    return notice;
  }

  // === ãƒ¦ãƒ¼ãƒ†ã‚£ãƒªãƒ†ã‚£ ===

  private generateId(prefix: string): string {
    const timestamp = Date.now();
    const random = Math.random().toString(36).substr(2, 9);
    return `${prefix}_${timestamp}_${random}`;
  }

  private getInitialData(): DatabaseSchema {
    return {
      users: {},
      positions: [
        { id: "pos_01", name: "æ´—ã„å ´", emoji: "ğŸ§½", sortOrder: 1 },
        { id: "pos_02", name: "1ãƒ¬ãƒ¼ãƒ³", emoji: "ğŸ½ï¸", sortOrder: 2 },
        { id: "pos_03", name: "2ãƒ¬ãƒ¼ãƒ³", emoji: "ğŸ–", sortOrder: 3 },
        { id: "pos_04", name: "ãƒ›ãƒ¼ãƒ«", emoji: "ğŸƒâ€â™€ï¸", sortOrder: 4 }
      ],
      shifts: {},
      shiftRequests: {},
      sharedNotices: [],
      dailyMessages: {},
      settings: {
        storeName: "ã€‡ã€‡ã€‡åº—",
        businessHours: "09:00-22:00",
        adminLineUserId: "",
        shiftDeadlineDay: 25,
        autoBreakEnabled: true,
        breakRules: { "6hours": 45, "8hours": 60 },
        timezone: "Asia/Tokyo"
      },
      substituteRequests: [],
      metadata: {
        version: "1.0.0",
        createdAt: new Date().toISOString(),
        lastUpdatedAt: new Date().toISOString(),
        totalUsers: 0,
        totalShifts: 0
      }
    };
  }

  private getDefaultValueForKey(key: string): any {
    const defaults = {
      users: {},
      positions: [],
      shifts: {},
      shiftRequests: {},
      sharedNotices: [],
      dailyMessages: {},
      settings: {},
      substituteRequests: [],
      metadata: {
        version: "1.0.0",
        createdAt: new Date().toISOString(),
        lastUpdatedAt: new Date().toISOString(),
        totalUsers: 0,
        totalShifts: 0
      }
    };
    
    return defaults[key] || {};
  }
}

// ã‚·ãƒ³ã‚°ãƒ«ãƒˆãƒ³ã‚¤ãƒ³ã‚¹ã‚¿ãƒ³ã‚¹
export const db = new JSONDatabase();
```

### 2. ãƒ‡ãƒ¼ã‚¿ãƒ™ãƒ¼ã‚¹ã‚¹ã‚­ãƒ¼ãƒå®šç¾©

```typescript
// types/database.ts
export interface DatabaseSchema {
  users: Record<string, User>;
  positions: Position[];
  shifts: Record<string,